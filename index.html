<!doctype html>



  


<html class="theme-next muse use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  <link href="//fonts.googleapis.com/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">



<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=0.5.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="Scarletsky" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=0.5.0" />






<meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="Scarletsky">
<meta property="og:url" content="http://scarletsky.github.io/index.html">
<meta property="og:site_name" content="Scarletsky">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Scarletsky">
<meta name="twitter:description">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> Scarletsky </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  








  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Scarletsky</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags fa-fw"></i> <br />
            
            标签
          </a>
        </li>
      

      
      
      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">

    

    
    

    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/02/09/what-is-functor-in-haskell/" itemprop="url">
                  What is functor in Haskell ?
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-02-09T22:50:13+08:00" content="2016-02-09">
              2016-02-09
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/02/09/what-is-functor-in-haskell/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/02/09/what-is-functor-in-haskell/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Functor__u7B80_u4ECB"><a href="#Functor__u7B80_u4ECB" class="headerlink" title="Functor 简介"></a>Functor 简介</h2><p>什么是 Functor ?</p>
<blockquote>
<p>现在你可以认为 Functor 是一种数据类型。</p>
</blockquote>
<p>Functor 有什么用 ?</p>
<blockquote>
<p>我们可以对 Functor 使用 <code>fmap</code>。</p>
</blockquote>
<p><code>fmap</code> 是什么东西 ?</p>
<blockquote>
<p><code>fmap</code> 是一个函数。</p>
</blockquote>
<p><code>fmap</code> 是函数的话，那它的类型签名是什么 ?</p>
<blockquote>
<p><code>fmap :: (a -&gt; b) -&gt; f a -&gt; f b</code>。</p>
</blockquote>
<p>我应该怎么看这个类型签名 ?</p>
<blockquote>
<p>它接受一个函数和一个 Functor 类型作为参数，然后返回另一个 Functor 。</p>
</blockquote>
<p><code>fmap</code> 有什么用 ?</p>
<blockquote>
<p>类似于 <code>map</code><br><code>map (+1) [1,2,3,4,5]  -- 返回 [2,3,4,5,6]</code><br><code>fmap (+1) [1,2,3,4,5] -- 返回 [2,3,4,5,6]</code></p>
</blockquote>
<p>所以列表是 Functor ?</p>
<blockquote>
<p>是的，List 是 Functor。</p>
</blockquote>
<p>为什么列表是 Functor ?</p>
<blockquote>
<p>因为列表实现了 <code>fmap</code>。</p>
<figure class="highlight hs"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Functor</span> [] <span class="keyword">where</span></span></span><br><span class="line">  fmap = map</span><br></pre></td></tr></table></figure>
</blockquote>
<p>实现了 <code>fmap</code> 的数据类型都是 Functor ?</p>
<blockquote>
<p>不一定。</p>
</blockquote>
<p>为什么 ?</p>
<blockquote>
<p>除了要实现 <code>fmap</code> 之外，还需要满足一些条件才能成为 Functor。</p>
</blockquote>
<p>满足什么条件 ?</p>
<blockquote>
<ol>
<li>必须保证 <code>fmap id = id</code>，也就是说 <code>fmap id xs</code> 和 <code>id xs</code> 必须返回相同的值。</li>
<li>必须是可组合的，两个 <code>fmap</code> 组合使用的结果应该和两个函数组合起来再用 <code>fmap</code> 的结果相同。<br>也就是说 <code>fmap f . fmap g</code> 必须等于 <code>fmap (f . g)</code>。</li>
</ol>
</blockquote>
<p>条件一是什么意思 ?</p>
<blockquote>
<p>意思是 <code>fmap</code> 只能对值调用 <code>f</code>，不能做额外的事情。</p>
</blockquote>
<p>有具体例子吗 ?</p>
<blockquote>
<p>看看这个经典的自定义数据类型，C表示计数器：</p>
<figure class="highlight hs"><table><tr><td class="code"><pre><span class="line"><span class="typedef"><span class="keyword">data</span> <span class="type">CMaybe</span> a = <span class="type">CNothing</span> | <span class="type">CJust</span> <span class="type">Int</span> a <span class="keyword">deriving</span> <span class="container">(<span class="type">Show</span>)</span></span></span><br><span class="line"><span class="class"></span><br><span class="line"><span class="keyword">instance</span> <span class="type">Functor</span> <span class="type">CMaybe</span> <span class="keyword">where</span></span></span><br><span class="line">  fmap f <span class="type">CNothing</span>          = <span class="type">CNothing</span></span><br><span class="line">  fmap f (<span class="type">CJust</span> counter x) = <span class="type">CJust</span> (counter + <span class="number">1</span>) (f x)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ghci</span></span><br><span class="line"></span><br><span class="line"><span class="title">ghci</span>&gt; fmap (++ <span class="string">"ha"</span>) (<span class="type">CJust</span> <span class="number">0</span> <span class="string">"ho"</span>)</span><br><span class="line"><span class="type">CJust</span> <span class="number">1</span> <span class="string">"hoha"</span></span><br><span class="line"><span class="title">ghci</span>&gt; fmap (++ <span class="string">"he"</span>) (fmap (++ <span class="string">"ha"</span>) (<span class="type">CJust</span> <span class="number">0</span> <span class="string">"ho"</span>))</span><br><span class="line"><span class="type">CJust</span> <span class="number">2</span> <span class="string">"hohahe"</span></span><br><span class="line"><span class="title">ghci</span>&gt; fmap (++ <span class="string">"blah"</span>) <span class="type">CNothing</span></span><br><span class="line"><span class="type">CNothing</span></span><br></pre></td></tr></table></figure>
<p>这里的 <code>fmap</code> 除了对值调用 <code>f</code> 之外，还对 <code>counter</code> 加一。</p>
</blockquote>
<p>这有什么问题吗 ?</p>
<blockquote>
<p>再看看 <code>fmap id</code> 和 <code>id</code><br><figure class="highlight hs"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; fmap id (<span class="type">CJust</span> <span class="number">0</span> <span class="string">"haha"</span>)</span><br><span class="line"><span class="type">CJust</span> <span class="number">1</span> <span class="string">"haha"</span></span><br><span class="line"><span class="title">ghci</span>&gt; id (<span class="type">Cjust</span> <span class="number">0</span> <span class="string">"haha"</span>)</span><br><span class="line"><span class="type">CJust</span> <span class="number">0</span> <span class="string">"haha"</span></span><br></pre></td></tr></table></figure></p>
<p>看出问题了吗 ?</p>
</blockquote>
<p><code>fmap id</code> 和 <code>id</code> 返回的结果不相等 ?</p>
<blockquote>
<p>是的，所以即便 <code>CMaybe a</code> 实现了 <code>fmap</code>，但它也不是 Functor。</p>
</blockquote>
<p>条件二有点像乘法分配律。</p>
<blockquote>
<p>是的。<br>乘法分配律是 <code>(a + b) x c = a x c + b x c</code>。<br>而条件二是 <code>fmap (f . g) = fmap f . fmap g</code>。</p>
</blockquote>
<p>条件二有具体例子吗 ?</p>
<blockquote>
<p>可以类比函数，因为函数本身也是 Functor，所以函数会满足<strong>可组合</strong>这个条件。<br>而实际应用中，我们也经常使用到函数组合这个特性。</p>
</blockquote>
<p>实现了 <code>fmap</code> ，同时满足两个条件的数据类型就是 Functor 吗？</p>
<blockquote>
<p>不，还有一个规则，就是该数据类型要有一个类型参数。</p>
</blockquote>
<p>能举个例子吗 ?</p>
<blockquote>
<p>我们已经知道 List 是一个 Functor，先看看 List 的定义：<br><figure class="highlight hs"><table><tr><td class="code"><pre><span class="line"><span class="typedef"><span class="keyword">data</span> [] a = [] | a : [a]</span></span><br></pre></td></tr></table></figure></p>
<p>列表有一个类型参数 a，表示一个列表中可以包含相同类型的元素。</p>
</blockquote>
<p>Functor 只能有一个类型参数吗？</p>
<blockquote>
<p>不是，我们可以通过其他方法让多于一个类型参数的数据类型都能成为 Functor 的实例。</p>
</blockquote>
<p>什么手段 ?</p>
<blockquote>
<p>你需要先知道怎么定义一个 Functor。</p>
</blockquote>
<h2 id="u81EA_u5B9A_u4E49_Functor"><a href="#u81EA_u5B9A_u4E49_Functor" class="headerlink" title="自定义 Functor"></a>自定义 Functor</h2><p>我应该怎么自定义 Functor ?</p>
<blockquote>
<p>先定义一个数据类型，再让该类型成为 Functor 的实例。<br><figure class="highlight hs"><table><tr><td class="code"><pre><span class="line"><span class="typedef"><span class="keyword">data</span> <span class="type">MyFunctor</span> a = <span class="type">Data</span> a <span class="keyword">deriving</span> <span class="container">(<span class="type">Show</span>)</span></span></span><br><span class="line"><span class="class"></span><br><span class="line"><span class="keyword">instance</span> <span class="type">Functor</span> <span class="type">MyFunctor</span> <span class="keyword">where</span></span></span><br><span class="line">  fmap f (<span class="type">Data</span> x) = <span class="type">Data</span> (f x)</span><br></pre></td></tr></table></figure></p>
<p>这样，我们定义的 MyFunctor 就是一个 Functor 了。</p>
</blockquote>
<p>刚才提到的让多于一个类型参数的数据类型成为 Functor 实例的方法是？</p>
<blockquote>
<p>利用 Haskell 中不全调用的特性。</p>
</blockquote>
<p>可以给个例子吗？</p>
<blockquote>
<figure class="highlight hs"><table><tr><td class="code"><pre><span class="line"><span class="typedef"><span class="keyword">data</span> <span class="type">MyFunctor2</span> a b = <span class="type">Data2</span> a b <span class="keyword">deriving</span> <span class="container">(<span class="type">Show</span>)</span></span></span><br><span class="line"><span class="class"></span><br><span class="line"><span class="keyword">instance</span> <span class="type">Functor</span> <span class="container">(<span class="type">MyFunctor2</span> <span class="title">a</span>)</span> <span class="keyword">where</span></span></span><br><span class="line">  fmap f (<span class="type">Data2</span> x y) = <span class="type">Data2</span> x (f y)</span><br></pre></td></tr></table></figure>
<p>在 Haskell 中，我们可以利用 Haskell 不全调用的特性，把 MyFunctor2 a 当成一个整体，这样就相当于只有 b 一个类型参数了。</p>
</blockquote>
<h2 id="u771F__B7_Functor"><a href="#u771F__B7_Functor" class="headerlink" title="真 · Functor"></a>真 · Functor</h2><p>我从上面看到，Functor 是一个类型类？</p>
<blockquote>
<p>是的。事实上，<strong>Functor 是一个类型类，表示满足一些条件的数据类型。</strong></p>
</blockquote>
<p>满足上面提到的条件？</p>
<blockquote>
<p>是的！</p>
</blockquote>
<p>有哪些常见的 Functor ？</p>
<blockquote>
<p><code>List</code>, <code>Maybe</code>等等。<br>你可以在 ghci 中输入 <code>:i Functor</code> 来查看更多预定义的 Functor。</p>
</blockquote>
<p>这些 Functor 有什么特点？</p>
<blockquote>
<p>它们都带有上下文：即可以表示有值，也可以表示空值。<br>[] 表示空值，[a] 表示有值；<br>Nothing 表示空值，Just a表示有值；</p>
</blockquote>
<p>这样有什么好处吗？</p>
<blockquote>
<p>好处是显然易见的。考虑下下面的伪代码：<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">post = Posts.find_by_id(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span> post</span><br><span class="line">  <span class="keyword">return</span> post.title</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">None</span></span><br></pre></td></tr></table></figure></p>
<p>为什么这段伪代码需要判断 post 是否为空？因为 post 没有上下文环境，不能表示空值。<br>如果 post 有上下文环境 (也就是 post 可以表示空值)，那么我们的代码就可以直接写成：<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">post = Posts.find_by_id(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> post.title</span><br></pre></td></tr></table></figure></p>
<p>因此，如果一个值可以带有上下文环境的话，我们的代码就可以写的非常简洁。</p>
</blockquote>
<p>把刚才的伪代码写成 Haskell 代码 ?</p>
<blockquote>
<p><code>fmap (getPostTitle) (findPosts 1)</code></p>
</blockquote>
<p><code>if else</code> 不见了？</p>
<blockquote>
<p>是的，这里假设 post 是一个 Functor，它可以表示带有空值的情况。所以 <code>if else</code> 就不需要了。</p>
</blockquote>
<p>那 <code>fmap</code> 呢？ 它事实上是什么东西？</p>
<blockquote>
<p><code>fmap</code> 确确实实是一个函数，它知道怎么把传进的函数应用到 Functor 中，并返回一个新的 Functor。</p>
</blockquote>
<p><code>fmap</code> 对 Functor 调用函数的过程发生了什么？</p>
<blockquote>
<p>看下面两张图 (图出自 <a href="http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html" target="_blank" rel="external">Functors, Applicatives, And Monads In Pictures</a>)：<br><img src="https://cloud.githubusercontent.com/assets/2386165/12949440/c8753e16-d042-11e5-84ff-b47753d65c52.png" alt="fmap_just"><br><img src="https://cloud.githubusercontent.com/assets/2386165/12949441/c87a69b8-d042-11e5-80d6-2ee458e13e37.png" alt="fmap_nothing"><br>实际上，<code>fmap</code> 先取出 Functor 中的值，然后把值传进函数中，再把函数的返回值放回到 Functor 中，最后返回新的 Functor。</p>
</blockquote>
<p>Functor 有什么限制？</p>
<blockquote>
<p><code>fmap f x</code> 中的 <code>f</code> 只接受一个参数。<br><code>fmap f x</code> 中的 <code>f</code> 不能带有上下文 (换句话说只能是 (+42) 不能是 <code>Just (+42)</code>)。</p>
</blockquote>
<p>关于 Functor 的知识，还有什么我是需要知道的 ？</p>
<blockquote>
<p><code>fmap</code> 可以中缀调用，即 <code>f `fmap` xs</code><br><code>&lt;$&gt;</code> 是 <code>fmap</code> 的别名，一般用于中缀调用，即 <code>f &lt;$&gt; xs</code>。</p>
</blockquote>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>Functor 是类型类，只要满足以下条件的数据类型都可以成为 Functor 的实例：</p>
<ul>
<li>实现 <code>fmap</code>。</li>
<li>保证 <code>fmap id = id</code>。</li>
<li>保证 <code>fmap (f . g) = fmap f . fmap g</code>。</li>
<li>该数据类型必须有一个以上的类型参数。</li>
</ul>
<p>最后，强烈建议看看 <a href="http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html" target="_blank" rel="external">这篇文章</a>，相当形象生动。</p>
<h2 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://learnyouahaskell.com/functors-applicative-functors-and-monoids" target="_blank" rel="external">Functors, Applicative Functors and Monoids</a><br><a href="http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html" target="_blank" rel="external">Functors, Applicatives, And Monads In Pictures</a><br><a href="http://cnhaskell.com/chp/10.html#functor" target="_blank" rel="external">Functor 简介</a><br><a href="http://stackoverflow.com/questions/2030863/in-functional-programming-what-is-a-functor" target="_blank" rel="external">http://stackoverflow.com/questions/2030863/in-functional-programming-what-is-a-functor</a></p>

          
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/02/06/random-numbers-in-haskell/" itemprop="url">
                  (译) Haskell 中随机数的使用
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-02-06T17:35:18+08:00" content="2016-02-06">
              2016-02-06
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/02/06/random-numbers-in-haskell/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/02/06/random-numbers-in-haskell/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>随机数（我指的是伪随机数）是通过显式或隐式的状态来生成的。这意味着在 Haskell 中，随机数的使用（通过 <code>System.Random</code> 库）是伴随着状态的传递的。 </p>
<p>大部分需要获得帮助的人都有命令式编程的背景，因此，我会先用命令式的方式，然后再用函数式的方式来教大家在 Haskell 中使用随机数。</p>
<h2 id="u4EFB_u52A1"><a href="#u4EFB_u52A1" class="headerlink" title="任务"></a>任务</h2><p>我会生成满足以下条件的随机列表：</p>
<ul>
<li>列表长度是 1 到 7 </li>
<li>列表中的每一项都是 0.0 到 1.0 之间的浮点数</li>
</ul>
<h2 id="u547D_u4EE4_u5F0F"><a href="#u547D_u4EE4_u5F0F" class="headerlink" title="命令式"></a>命令式</h2><p>在 IO monad 中有一个全局的生成器，你可以初始化它，然后获取随机数。下面有一些常用的函数：</p>
<h3 id="setStdGen__3A_3A_StdGen_-_26gt_3B_IO__28_29"><a href="#setStdGen__3A_3A_StdGen_-_26gt_3B_IO__28_29" class="headerlink" title="setStdGen :: StdGen -&gt; IO ()"></a><code>setStdGen :: StdGen -&gt; IO ()</code></h3><p>初始化或者设置全局生成器，我们可以用 <code>mkStdGen</code> 来生成随机种子。因此，有一个很傻瓜式的用法：</p>
<figure class="highlight hs"><table><tr><td class="code"><pre><span class="line"><span class="title">setStdGen</span> (mkStdGen <span class="number">42</span>)</span><br></pre></td></tr></table></figure>
<p>当然，你可以用任意的 <code>Int</code> 来替换 <code>42</code>。</p>
<p>其实，你可以选择是否调用 <code>setStdGen</code>，如果你不调用的话，全局的生成器还是可用的。因为在 runtime 会在启动的时候用一个任意的种子去初始化它，所以每次启动的时候，都会有一个不同的种子。</p>
<h3 id="randomRIO__3A_3A__28Random_a_29__3D_26gt_3B__28a_2Ca_29_-_26gt_3B_IO_a"><a href="#randomRIO__3A_3A__28Random_a_29__3D_26gt_3B__28a_2Ca_29_-_26gt_3B_IO_a" class="headerlink" title="randomRIO :: (Random a) =&gt; (a,a) -&gt; IO a"></a><code>randomRIO :: (Random a) =&gt; (a,a) -&gt; IO a</code></h3><p>在给定范围随机返回一个类型为 <code>a</code> 的值，同时全局生成器也会更新。你可以通过一个元组来指定范围。下面这个例子会返回 <code>a</code> 到 <code>z</code> 之间的随机值（包含 <code>a</code> 和 <code>z</code>）：</p>
<figure class="highlight hs"><table><tr><td class="code"><pre><span class="line"><span class="title">c</span> &lt;- randomRIO ('a', 'z')</span><br></pre></td></tr></table></figure>
<p><code>a</code> 可以是任意类型吗？并非如此。在 Haskell 98 标准中， <code>Random</code> 库只支持 <code>Bool</code>, <code>Char</code>,  <code>Int</code>, <code>Integer</code>, <code>Float</code>, <code>Double</code>（你可以自己去扩展这个支持的范围，但这是另外一个话题了）。</p>
<h3 id="randomIO__3A_3A__28Random_a_29__3D_26gt_3B_IO_a"><a href="#randomIO__3A_3A__28Random_a_29__3D_26gt_3B_IO_a" class="headerlink" title="randomIO :: (Random a) =&gt; IO a"></a><code>randomIO :: (Random a) =&gt; IO a</code></h3><p>返回一个类型为 <code>a</code> 的随机数（<code>a</code> 可以是任意类型吗？看上文），全局的生成器也会更新。下面这个例子会返回一个 <code>Double</code> 类型的随机数：</p>
<figure class="highlight hs"><table><tr><td class="code"><pre><span class="line"><span class="title">x</span> &lt;- randomIO :: <span class="type">IO</span> <span class="type">Double</span></span><br></pre></td></tr></table></figure>
<p>随机数返回的范围由类型决定。</p>
<p>需要注意的是，这些都是 IO 函数，因此你只可以在 IO 函数中使用它们。换句话说，如果你写了一个要使用它们的函数，它的返回类型也会变成是 IO 函数。</p>
<p>举个例子，上面提到的代码片段都要写在 <code>do block</code> 中。这只是一个提醒，因为我们想要用命令式的方式来生成随机数。</p>
<p>下面这个例子展示如何在 IO monad 中完成之前的任务：</p>
<figure class="highlight hs"><table><tr><td class="code"><pre><span class="line"><span class="import"><span class="keyword">import</span> System.Random</span></span><br><span class="line"></span><br><span class="line"><span class="title">main</span> = <span class="keyword">do</span></span><br><span class="line">    setStdGen (mkStdGen <span class="number">42</span>)  <span class="comment">-- 这步是可选的，如果有这一步，你每一次运行的结果都是一样的，因为随机种子固定是 42</span></span><br><span class="line">    s &lt;- randomStuff</span><br><span class="line">    print s</span><br><span class="line"></span><br><span class="line"><span class="title">randomStuff</span> :: <span class="type">IO</span> [<span class="type">Float</span>]</span><br><span class="line"><span class="title">randomStuff</span> = <span class="keyword">do</span></span><br><span class="line">    n &lt;- randomRIO (<span class="number">1</span>, <span class="number">7</span>)</span><br><span class="line">    sequence (replicate n (randomRIO (<span class="number">0</span>, <span class="number">1</span>)))</span><br></pre></td></tr></table></figure>
<h2 id="u7EAF_u51FD_u6570_u5F0F"><a href="#u7EAF_u51FD_u6570_u5F0F" class="headerlink" title="纯函数式"></a>纯函数式</h2><p>你可能有以下原因想知道如何用函数式的方式生成随机数：</p>
<ul>
<li>你有好奇心</li>
<li>你不想用 IO monad</li>
<li>因为一些并发或者其他原因，你想几个生成器同时存在，共享全局生成器不能解决你的问题</li>
</ul>
<p>实际上，有两种方法来用函数式的方式去生成随机数：</p>
<ul>
<li>从 stream（无限列表） 中提取随机数</li>
<li>把生成器当成函数参数的一部分，然后返回随机数</li>
</ul>
<p>这里有一些常用的函数用来创建生成器和包含随机数的无限列表。</p>
<h3 id="mkStdGen__3A_3A_Int_-_26gt_3B_StdGen"><a href="#mkStdGen__3A_3A_Int_-_26gt_3B_StdGen" class="headerlink" title="mkStdGen :: Int -&gt; StdGen"></a><code>mkStdGen :: Int -&gt; StdGen</code></h3><p>用随机种子创建生成器。</p>
<h3 id="randomRs__3A_3A__28Random_a_2C_RandomGen_g_29__3D_26gt_3B__28a_2C_a_29_-_26gt_3B_g_-_26gt_3B__5Ba_5D"><a href="#randomRs__3A_3A__28Random_a_2C_RandomGen_g_29__3D_26gt_3B__28a_2C_a_29_-_26gt_3B_g_-_26gt_3B__5Ba_5D" class="headerlink" title="randomRs :: (Random a, RandomGen g) =&gt; (a, a) -&gt; g -&gt; [a]"></a><code>randomRs :: (Random a, RandomGen g) =&gt; (a, a) -&gt; g -&gt; [a]</code></h3><p>用生成器生成给定范围的无限列表。例子：用 <code>42</code> 作为随机种子，返回 <code>a</code> 到 <code>z</code> 之间包含 <code>a</code> 和 <code>z</code> 的无限列表：</p>
<figure class="highlight hs"><table><tr><td class="code"><pre><span class="line"><span class="title">randomRs</span> ('a', 'z') (mkStdGen <span class="number">42</span>)</span><br></pre></td></tr></table></figure>
<p>类型 <code>a</code> 是随机数的类型。类型 <code>g</code> 看起来是通用的，但实际上它总是 <code>StdGen</code>。</p>
<h3 id="randoms__3A_3A__28Random_a_2C_RandomGen_g_29__3D_26gt_3B_g_-_26gt_3B__5Ba_5D"><a href="#randoms__3A_3A__28Random_a_2C_RandomGen_g_29__3D_26gt_3B_g_-_26gt_3B__5Ba_5D" class="headerlink" title="randoms :: (Random a, RandomGen g) =&gt; g -&gt; [a]"></a><code>randoms :: (Random a, RandomGen g) =&gt; g -&gt; [a]</code></h3><p>用给定的生成器生成随机数的无限列表。例如：用 <code>42</code> 作为随机种子生成 <code>Double</code> 类型的列表：</p>
<figure class="highlight hs"><table><tr><td class="code"><pre><span class="line"><span class="title">randoms</span> (mkStdGen <span class="number">42</span>) :: [<span class="type">Double</span>]</span><br></pre></td></tr></table></figure>
<p>随机数的范围由类型决定，你需要查文档来确定具体范围，或者直接用 <code>randomRs</code>。</p>
<p>注意，这些都是函数式的 —— 意味着这里面没有副作用，特别是生成器并不会更新。如果你用一个生成器去生成第一个列表，然后用相同的生成器去生成第二个列表…</p>
<figure class="highlight hs"><table><tr><td class="code"><pre><span class="line"><span class="title">g</span> = mkStdGen <span class="number">42</span></span><br><span class="line"><span class="title">a</span> = randoms g :: [<span class="type">Double</span>]</span><br><span class="line"><span class="title">b</span> = randoms g :: [<span class="type">Double</span>]</span><br></pre></td></tr></table></figure>
<p>猜猜结果，由于透明引用，这两个列表的结果是一样的！（如果你想用一个随机种子来生成两个不同的列表，我等下告诉你一个方法）。</p>
<p>下面一种方法来完成创建 <code>1</code> 到 <code>7</code> 的随机列表：</p>
<figure class="highlight hs"><table><tr><td class="code"><pre><span class="line"><span class="import"><span class="keyword">import</span> System.Random</span></span><br><span class="line"></span><br><span class="line"><span class="title">main</span> = <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">let</span> g   = mkStdGen <span class="number">42</span></span><br><span class="line">    <span class="keyword">let</span> [s] = take <span class="number">1</span> (randomStuff g)</span><br><span class="line">    print s</span><br><span class="line"></span><br><span class="line"><span class="title">randomStuff</span> :: <span class="type">RandomGen</span> g =&gt; g -&gt; [[<span class="type">Float</span>]]</span><br><span class="line"><span class="title">randomStuff</span> g = work (randomRs (<span class="number">0.0</span>, <span class="number">1.0</span>) g)</span><br><span class="line"></span><br><span class="line"><span class="title">work</span> :: [<span class="type">Float</span>] -&gt; [[<span class="type">Float</span>]]</span><br><span class="line"><span class="title">work</span> (r:rs)      =</span><br><span class="line">    <span class="keyword">let</span> n        = truncate (r * <span class="number">7.0</span>) + <span class="number">1</span></span><br><span class="line">        (xs, ys) = splitAt n rs</span><br><span class="line">    <span class="keyword">in</span> xs : work ys</span><br></pre></td></tr></table></figure>
<p>除了必要的打印操作外，这是纯函数式的。它用生成器生成了无限列表，然后再用这个无限列表来生成另一个无限列表作为答案，最后取第一个作为返回值。</p>
<p>我这样做是因为尽管我们今天的人物是生成一个随机数，但你通常会需要很多个，我希望这个例子可以对你有点帮助。</p>
<p>上面的代码的工作原理是：用一个生成器，创建一个包含 <code>Float</code> 的无限列表。截取第一个值，并扩大这个值到 <code>1</code> 到 <code>7</code>，然后用剩下的列表来生成答案。换句话说，把输入的列表分成 <code>(r:rs)</code>，<code>r</code> 决定生成列表的长度（<code>1</code> 到 <code>7</code>），<code>rs</code> 之后会被计算答案。</p>
<h3 id="split__3A_3A__28RandomGen_g_29__3D_26gt_3B_g_-_26gt_3B__28g_2C_g_29"><a href="#split__3A_3A__28RandomGen_g_29__3D_26gt_3B_g_-_26gt_3B__28g_2C_g_29" class="headerlink" title="split :: (RandomGen g) =&gt; g -&gt; (g, g)"></a><code>split :: (RandomGen g) =&gt; g -&gt; (g, g)</code></h3><p>用一个随机种子创建两个不同的生成器，其他情况下重用相同的种子是不明智的。</p>
<figure class="highlight hs"><table><tr><td class="code"><pre><span class="line"><span class="title">g</span> = mkStdGen <span class="number">42</span></span><br><span class="line">(ga, gb) = split g</span><br><span class="line"><span class="comment">-- do not use g elsewhere</span></span><br></pre></td></tr></table></figure>
<p>如果你想创建多余两个的生成器，你可以对新的生成器中的其中一个使用 <code>split</code>：</p>
<figure class="highlight hs"><table><tr><td class="code"><pre><span class="line"><span class="title">g</span> = mkStdGen <span class="number">42</span></span><br><span class="line">(ga, g') = split g</span><br><span class="line">(gb, gc) = split g'</span><br><span class="line"><span class="comment">-- do not use g, g' elsewhere</span></span><br></pre></td></tr></table></figure>
<p>我们可以用 <code>split</code> 来获得两个生成器，这样我们就可以产生两个随机列表了。</p>
<figure class="highlight hs"><table><tr><td class="code"><pre><span class="line"><span class="title">randomStuff</span> :: <span class="type">RandomGen</span> g =&gt; g -&gt; [[<span class="type">Float</span>]]</span><br><span class="line"><span class="title">randomStuff</span> g = work (randomRs (<span class="number">1</span>, <span class="number">7</span>) ga) (randomRs (<span class="number">0.0</span>, <span class="number">1.0</span>) gb)</span><br><span class="line">    <span class="keyword">where</span> (ga,gb) = split g</span><br><span class="line"></span><br><span class="line"><span class="title">work</span> :: [<span class="type">Int</span>] -&gt; [<span class="type">Float</span>] -&gt; [[<span class="type">Float</span>]]</span><br><span class="line"><span class="title">work</span> (n:ns) rs =</span><br><span class="line">    <span class="keyword">let</span> (xs,ys) = splitAt n rs</span><br><span class="line">    <span class="keyword">in</span> xs : work ns ys</span><br></pre></td></tr></table></figure>
<p>它把生成器分成两个，然后产生两个列表。</p>
<p>我在主程序中硬编码了随机种子。正常情况下你可以在其他地方获取随机种子 —— 从输入中获取，从文件中获取，从时间上获取，或者从某些设备中获取。</p>
<p>这些在主程序中都是 do-able 的，因为它们都可以在 IO monad 中访问。</p>
<p>你也可以通过 <code>getStdGen</code> 获取全局生成器：</p>
<figure class="highlight hs"><table><tr><td class="code"><pre><span class="line"><span class="title">main</span> = <span class="keyword">do</span></span><br><span class="line">    g &lt;- getStdGen</span><br><span class="line">    <span class="keyword">let</span> [s] = take randomStuff g</span><br><span class="line">    print s</span><br></pre></td></tr></table></figure>
<h2 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://www.vex.net/~trebla/haskell/random.xhtml" target="_blank" rel="external">原文</a></p>

          
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/01/30/nodejs-process-excel/" itemprop="url">
                  在 Node.js 中利用 js-xlsx 处理 Excel 文件
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-01-30T11:31:46+08:00" content="2016-01-30">
              2016-01-30
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/01/30/nodejs-process-excel/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/01/30/nodejs-process-excel/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="u7B80_u4ECB"><a href="#u7B80_u4ECB" class="headerlink" title="简介"></a>简介</h2><p>本文介绍用 Node.js 中的 <code>js-xlsx</code> 库来处理 Excel 文件。<br><code>js-xlsx</code> 库是目前 Github 上 star 数量最多的处理 Excel 的库，功能强大，但上手难度稍大。文档有些乱，不适合快速上手。<br>本文对 <code>js-xlsx</code> 库进行一定的总结，并提供几个实用的例子供读者测试，学习，交流。</p>
<h2 id="u5B89_u88C5"><a href="#u5B89_u88C5" class="headerlink" title="安装"></a>安装</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install xlsx</span><br></pre></td></tr></table></figure>
<h2 id="u4E00_u4E9B_u6982_u5FF5"><a href="#u4E00_u4E9B_u6982_u5FF5" class="headerlink" title="一些概念"></a>一些概念</h2><p>在使用这个库之前，先介绍库中的一些概念。</p>
<ul>
<li><p><code>workbook</code> 对象，指的是整份 Excel 文档。我们在使用 <code>js-xlsx</code> 读取 Excel 文档之后就会获得 <code>workbook</code> 对象。</p>
</li>
<li><p><code>worksheet</code> 对象，指的是 Excel 文档中的表。我们知道一份 Excel 文档中可以包含很多张表，而每张表对应的就是 <code>worksheet</code> 对象。</p>
</li>
<li><p><code>cell</code> 对象，指的就是 <code>worksheet</code> 中的单元格，一个单元格就是一个 <code>cell</code> 对象。</p>
</li>
</ul>
<p>它们的关系如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// workbook</span></span><br><span class="line">&#123;</span><br><span class="line">    SheetNames: [<span class="string">'sheet1'</span>, <span class="string">'sheet2'</span>],</span><br><span class="line">    Sheets: &#123;</span><br><span class="line">        <span class="comment">// worksheet</span></span><br><span class="line">        <span class="string">'sheet1'</span>: &#123;</span><br><span class="line">            <span class="comment">// cell</span></span><br><span class="line">            <span class="string">'A1'</span>: &#123; ... &#125;,</span><br><span class="line">            <span class="comment">// cell</span></span><br><span class="line">            <span class="string">'A2'</span>: &#123; ... &#125;,</span><br><span class="line">            ...</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// worksheet</span></span><br><span class="line">        <span class="string">'sheet2'</span>: &#123;</span><br><span class="line">            <span class="comment">// cell</span></span><br><span class="line">            <span class="string">'A1'</span>: &#123; ... &#125;,</span><br><span class="line">            <span class="comment">// cell</span></span><br><span class="line">            <span class="string">'A2'</span>: &#123; ... &#125;,</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u7528_u6CD5"><a href="#u7528_u6CD5" class="headerlink" title="用法"></a>用法</h2><h3 id="u57FA_u672C_u7528_u6CD5"><a href="#u57FA_u672C_u7528_u6CD5" class="headerlink" title="基本用法"></a>基本用法</h3><ol>
<li>用 <code>XLSX.readFile</code> 打开 Excel 文件，返回 <code>workbook</code></li>
<li>用 <code>workbook.SheetNames</code> 获取表名</li>
<li>用 <code>workbook.Sheets[xxx]</code> 通过表名获取表格</li>
<li>按自己的需求去处理表格</li>
<li>生成新的 Excel 文件</li>
</ol>
<h3 id="u5177_u4F53_u7528_u6CD5"><a href="#u5177_u4F53_u7528_u6CD5" class="headerlink" title="具体用法"></a>具体用法</h3><p>读取 Excel 文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> XLSX <span class="keyword">from</span> <span class="string">'xlsx'</span>;</span><br><span class="line"><span class="keyword">const</span> workbook = XLSX.readFile(<span class="string">'someExcel.xlsx'</span>, opts);</span><br></pre></td></tr></table></figure>
<p>获取 Excel 文件中的表</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取 Excel 中所有表名</span></span><br><span class="line"><span class="keyword">const</span> sheetNames = workbook.SheetNames; <span class="comment">// 返回 ['sheet1', 'sheet2']</span></span><br><span class="line"><span class="comment">// 根据表名获取对应某张表</span></span><br><span class="line"><span class="keyword">const</span> worksheet = workbook.Sheets[sheetNames[<span class="number">0</span>]];</span><br></pre></td></tr></table></figure>
<p>通过 <code>worksheet[address]</code> 来操作表格，以 <code>!</code> 开头的 key 是特殊的字段。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取 A1 单元格对象</span></span><br><span class="line"><span class="keyword">let</span> a1 = worksheet[<span class="string">'A1'</span>]; <span class="comment">// 返回 &#123; v: 'hello', t: 's', ... &#125;</span></span><br><span class="line"><span class="comment">// 获取 A1 中的值</span></span><br><span class="line">a1.v <span class="comment">// 返回 'hello'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取表的有效范围</span></span><br><span class="line">worksheet[<span class="string">'!ref'</span>] <span class="comment">// 返回 'A1:B20'</span></span><br><span class="line">worksheet[<span class="string">'!range'</span>] <span class="comment">// 返回 range 对象，&#123; s: &#123; r: 0, c: 0&#125;, e: &#123; r: 100, c: 2 &#125; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取合并过的单元格</span></span><br><span class="line">worksheet[<span class="string">'!merges'</span>] <span class="comment">// 返回一个包含 range 对象的列表，[ &#123;s: &#123; r: 0, c: 0 &#125;, c: &#123; r: 2, c: 1 &#125; &#125; ]</span></span><br></pre></td></tr></table></figure>
<h3 id="u5B9E_u6218"><a href="#u5B9E_u6218" class="headerlink" title="实战"></a>实战</h3><h4 id="u89E3_u6790_Excel__u751F_u6210_JSON"><a href="#u89E3_u6790_Excel__u751F_u6210_JSON" class="headerlink" title="解析 Excel 生成 JSON"></a>解析 Excel 生成 JSON</h4><blockquote>
<p><strong>Tips</strong> 事实上，你可以直接通过 <code>XLSX.utils.sheet_to_json(worksheet)</code> 获得同样的结果</p>
</blockquote>
<p><strong>注意</strong> 本例子中假设表的第一行为字段名</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> headers = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> data = [];</span><br><span class="line"><span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(worksheet);</span><br><span class="line">keys</span><br><span class="line">    <span class="comment">// 过滤以 ! 开头的 key</span></span><br><span class="line">    .filter(k =&gt; k[<span class="number">0</span>] !== <span class="string">'!'</span>)</span><br><span class="line">    <span class="comment">// 遍历所有单元格</span></span><br><span class="line">    .forEach(k =&gt; &#123;</span><br><span class="line">        <span class="comment">// 如 A11 中的 A</span></span><br><span class="line">        <span class="keyword">let</span> col = k.substring(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 如 A11 中的 11</span></span><br><span class="line">        <span class="keyword">let</span> row = <span class="built_in">parseInt</span>(k.substring(<span class="number">1</span>));</span><br><span class="line">        <span class="comment">// 当前单元格的值</span></span><br><span class="line">        <span class="keyword">let</span> value = worksheet[k].v;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 保存字段名</span></span><br><span class="line">        <span class="keyword">if</span> (row === <span class="number">1</span>) &#123;</span><br><span class="line">            headers[col] = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解析成 JSON</span></span><br><span class="line">        <span class="keyword">if</span> (!data[row]) &#123;</span><br><span class="line">            data[row] = &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        data[row][headers[col]] = value;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(data); <span class="comment">// [ &#123; '姓名': 'test1', '年龄': 20 &#125;, &#123; '姓名': 'test2', '年龄': 10 &#125; ... ]</span></span><br></pre></td></tr></table></figure>
<h4 id="u5408_u5E76_u8868_u683C"><a href="#u5408_u5E76_u8868_u683C" class="headerlink" title="合并表格"></a>合并表格</h4><p>步骤：</p>
<ol>
<li>读取多份表格</li>
<li>合并数组</li>
</ol>
<p><strong>Tips:</strong> 其实合并表格跟 <code>XLSX</code> 没什么关系，只是处理几个数组而已。</p>
<p>sheet1</p>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>age</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>test1</td>
<td>30</td>
</tr>
<tr>
<td>2</td>
<td>test2</td>
<td>20</td>
</tr>
<tr>
<td>3</td>
<td>test3</td>
<td>18</td>
</tr>
</tbody>
</table>
<p>sheet2</p>
<table>
<thead>
<tr>
<th>id</th>
<th>country</th>
<th>remark</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>China</td>
<td>hello</td>
</tr>
<tr>
<td>2</td>
<td>America</td>
<td>world</td>
</tr>
<tr>
<td>3</td>
<td>Unkonw</td>
<td>???</td>
</tr>
</tbody>
</table>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sheet1 = XLSX.utils.sheet_to_json(sheet1);</span><br><span class="line"><span class="keyword">let</span> sheet2 = XLSX.utils.sheet_to_json(sheet2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先合并 sheet1 和 sheet2，再对统一处理</span></span><br><span class="line"><span class="keyword">const</span> result = sheet1.concat(sheet2).reduce((prev, next) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> index = prev.findIndex((elem, i) =&gt; elem.id === next.id);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index === -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> prev.concat(next);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        prev[index] = <span class="built_in">Object</span>.assign(&#123;&#125;, prev[index], next);</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, []);</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br><span class="line"></span><br><span class="line"><span class="comment">// [ &#123; id: '1',</span></span><br><span class="line"><span class="comment">//    name: 'test1',</span></span><br><span class="line"><span class="comment">//    age: '30',</span></span><br><span class="line"><span class="comment">//    country: 'China',</span></span><br><span class="line"><span class="comment">//    remark: 'hello' &#125;,</span></span><br><span class="line"><span class="comment">//  &#123; id: '2',</span></span><br><span class="line"><span class="comment">//    name: 'test2',</span></span><br><span class="line"><span class="comment">//    age: '20',</span></span><br><span class="line"><span class="comment">//    country: 'America',</span></span><br><span class="line"><span class="comment">//    remark: 'world' &#125;,</span></span><br><span class="line"><span class="comment">//  &#123; id: '3',</span></span><br><span class="line"><span class="comment">//    name: 'test3',</span></span><br><span class="line"><span class="comment">//    age: '18',</span></span><br><span class="line"><span class="comment">//    country: 'Unkonw',</span></span><br><span class="line"><span class="comment">//    remark: '???' &#125; ]</span></span><br></pre></td></tr></table></figure>
<h4 id="u5BFC_u51FA_u8868_u683C"><a href="#u5BFC_u51FA_u8868_u683C" class="headerlink" title="导出表格"></a>导出表格</h4><p>步骤：</p>
<ol>
<li>构建特定的数据结构，如下。</li>
<li>调用 <code>XLSX.writeFile(workbook, filename)</code> 即可。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// workbook</span></span><br><span class="line">&#123;</span><br><span class="line">    SheetNames: [<span class="string">'mySheet'</span>],</span><br><span class="line">    Sheets: &#123;</span><br><span class="line">        <span class="string">'mySheet'</span>: &#123;</span><br><span class="line">            <span class="string">'!ref'</span>: <span class="string">'A1:E4'</span>, <span class="comment">// 必须要有这个范围才能输出，否则导出的 excel 会是一个空表</span></span><br><span class="line">            A1: &#123; v: <span class="string">'id'</span> &#125;,</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> _headers = [<span class="string">'id'</span>, <span class="string">'name'</span>, <span class="string">'age'</span>, <span class="string">'country'</span>, <span class="string">'remark'</span>]</span><br><span class="line"><span class="keyword">var</span> _data = [ &#123; id: <span class="string">'1'</span>,</span><br><span class="line">                name: <span class="string">'test1'</span>,</span><br><span class="line">                age: <span class="string">'30'</span>,</span><br><span class="line">                country: <span class="string">'China'</span>,</span><br><span class="line">                remark: <span class="string">'hello'</span> &#125;,</span><br><span class="line">              &#123; id: <span class="string">'2'</span>,</span><br><span class="line">                name: <span class="string">'test2'</span>,</span><br><span class="line">                age: <span class="string">'20'</span>,</span><br><span class="line">                country: <span class="string">'America'</span>,</span><br><span class="line">                remark: <span class="string">'world'</span> &#125;,</span><br><span class="line">              &#123; id: <span class="string">'3'</span>,</span><br><span class="line">                name: <span class="string">'test3'</span>,</span><br><span class="line">                age: <span class="string">'18'</span>,</span><br><span class="line">                country: <span class="string">'Unkonw'</span>,</span><br><span class="line">                remark: <span class="string">'???'</span> &#125; ];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> headers = _headers</span><br><span class="line">                <span class="comment">// 为 _headers 添加对应的单元格位置</span></span><br><span class="line">                <span class="comment">// [ &#123; v: 'id', position: 'A1' &#125;,</span></span><br><span class="line">                <span class="comment">//   &#123; v: 'name', position: 'B1' &#125;,</span></span><br><span class="line">                <span class="comment">//   &#123; v: 'age', position: 'C1' &#125;,</span></span><br><span class="line">                <span class="comment">//   &#123; v: 'country', position: 'D1' &#125;,</span></span><br><span class="line">                <span class="comment">//   &#123; v: 'remark', position: 'E1' &#125; ]</span></span><br><span class="line">                .map((v, i) =&gt; <span class="built_in">Object</span>.assign(&#123;&#125;, &#123;v: v, position: <span class="built_in">String</span>.fromCharCode(<span class="number">65</span>+i) + <span class="number">1</span> &#125;))</span><br><span class="line">                <span class="comment">// 转换成 worksheet 需要的结构</span></span><br><span class="line">                <span class="comment">// &#123; A1: &#123; v: 'id' &#125;,</span></span><br><span class="line">                <span class="comment">//   B1: &#123; v: 'name' &#125;,</span></span><br><span class="line">                <span class="comment">//   C1: &#123; v: 'age' &#125;,</span></span><br><span class="line">                <span class="comment">//   D1: &#123; v: 'country' &#125;,</span></span><br><span class="line">                <span class="comment">//   E1: &#123; v: 'remark' &#125; &#125;</span></span><br><span class="line">                .reduce((prev, next) =&gt; <span class="built_in">Object</span>.assign(&#123;&#125;, prev, &#123;[next.position]: &#123;v: next.v&#125;&#125;), &#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> data = _data</span><br><span class="line">              <span class="comment">// 匹配 headers 的位置，生成对应的单元格数据</span></span><br><span class="line">              <span class="comment">// [ [ &#123; v: '1', position: 'A2' &#125;,</span></span><br><span class="line">              <span class="comment">//     &#123; v: 'test1', position: 'B2' &#125;,</span></span><br><span class="line">              <span class="comment">//     &#123; v: '30', position: 'C2' &#125;,</span></span><br><span class="line">              <span class="comment">//     &#123; v: 'China', position: 'D2' &#125;,</span></span><br><span class="line">              <span class="comment">//     &#123; v: 'hello', position: 'E2' &#125; ],</span></span><br><span class="line">              <span class="comment">//   [ &#123; v: '2', position: 'A3' &#125;,</span></span><br><span class="line">              <span class="comment">//     &#123; v: 'test2', position: 'B3' &#125;,</span></span><br><span class="line">              <span class="comment">//     &#123; v: '20', position: 'C3' &#125;,</span></span><br><span class="line">              <span class="comment">//     &#123; v: 'America', position: 'D3' &#125;,</span></span><br><span class="line">              <span class="comment">//     &#123; v: 'world', position: 'E3' &#125; ],</span></span><br><span class="line">              <span class="comment">//   [ &#123; v: '3', position: 'A4' &#125;,</span></span><br><span class="line">              <span class="comment">//     &#123; v: 'test3', position: 'B4' &#125;,</span></span><br><span class="line">              <span class="comment">//     &#123; v: '18', position: 'C4' &#125;,</span></span><br><span class="line">              <span class="comment">//     &#123; v: 'Unkonw', position: 'D4' &#125;,</span></span><br><span class="line">              <span class="comment">//     &#123; v: '???', position: 'E4' &#125; ] ]</span></span><br><span class="line">              .map((v, i) =&gt; _headers.map((k, j) =&gt; <span class="built_in">Object</span>.assign(&#123;&#125;, &#123; v: v[k], position: <span class="built_in">String</span>.fromCharCode(<span class="number">65</span>+j) + (i+<span class="number">2</span>) &#125;)))</span><br><span class="line">              <span class="comment">// 对刚才的结果进行降维处理（二维数组变成一维数组）</span></span><br><span class="line">              <span class="comment">// [ &#123; v: '1', position: 'A2' &#125;,</span></span><br><span class="line">              <span class="comment">//   &#123; v: 'test1', position: 'B2' &#125;,</span></span><br><span class="line">              <span class="comment">//   &#123; v: '30', position: 'C2' &#125;,</span></span><br><span class="line">              <span class="comment">//   &#123; v: 'China', position: 'D2' &#125;,</span></span><br><span class="line">              <span class="comment">//   &#123; v: 'hello', position: 'E2' &#125;,</span></span><br><span class="line">              <span class="comment">//   &#123; v: '2', position: 'A3' &#125;,</span></span><br><span class="line">              <span class="comment">//   &#123; v: 'test2', position: 'B3' &#125;,</span></span><br><span class="line">              <span class="comment">//   &#123; v: '20', position: 'C3' &#125;,</span></span><br><span class="line">              <span class="comment">//   &#123; v: 'America', position: 'D3' &#125;,</span></span><br><span class="line">              <span class="comment">//   &#123; v: 'world', position: 'E3' &#125;,</span></span><br><span class="line">              <span class="comment">//   &#123; v: '3', position: 'A4' &#125;,</span></span><br><span class="line">              <span class="comment">//   &#123; v: 'test3', position: 'B4' &#125;,</span></span><br><span class="line">              <span class="comment">//   &#123; v: '18', position: 'C4' &#125;,</span></span><br><span class="line">              <span class="comment">//   &#123; v: 'Unkonw', position: 'D4' &#125;,</span></span><br><span class="line">              <span class="comment">//   &#123; v: '???', position: 'E4' &#125; ]</span></span><br><span class="line">              .reduce((prev, next) =&gt; prev.concat(next))</span><br><span class="line">              <span class="comment">// 转换成 worksheet 需要的结构</span></span><br><span class="line">              <span class="comment">//   &#123; A2: &#123; v: '1' &#125;,</span></span><br><span class="line">              <span class="comment">//     B2: &#123; v: 'test1' &#125;,</span></span><br><span class="line">              <span class="comment">//     C2: &#123; v: '30' &#125;,</span></span><br><span class="line">              <span class="comment">//     D2: &#123; v: 'China' &#125;,</span></span><br><span class="line">              <span class="comment">//     E2: &#123; v: 'hello' &#125;,</span></span><br><span class="line">              <span class="comment">//     A3: &#123; v: '2' &#125;,</span></span><br><span class="line">              <span class="comment">//     B3: &#123; v: 'test2' &#125;,</span></span><br><span class="line">              <span class="comment">//     C3: &#123; v: '20' &#125;,</span></span><br><span class="line">              <span class="comment">//     D3: &#123; v: 'America' &#125;,</span></span><br><span class="line">              <span class="comment">//     E3: &#123; v: 'world' &#125;,</span></span><br><span class="line">              <span class="comment">//     A4: &#123; v: '3' &#125;,</span></span><br><span class="line">              <span class="comment">//     B4: &#123; v: 'test3' &#125;,</span></span><br><span class="line">              <span class="comment">//     C4: &#123; v: '18' &#125;,</span></span><br><span class="line">              <span class="comment">//     D4: &#123; v: 'Unkonw' &#125;,</span></span><br><span class="line">              <span class="comment">//     E4: &#123; v: '???' &#125; &#125;</span></span><br><span class="line">              .reduce((prev, next) =&gt; <span class="built_in">Object</span>.assign(&#123;&#125;, prev, &#123;[next.position]: &#123;v: next.v&#125;&#125;), &#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并 headers 和 data</span></span><br><span class="line"><span class="keyword">var</span> output = <span class="built_in">Object</span>.assign(&#123;&#125;, headers, data);</span><br><span class="line"><span class="comment">// 获取所有单元格的位置</span></span><br><span class="line"><span class="keyword">var</span> outputPos = <span class="built_in">Object</span>.keys(output);</span><br><span class="line"><span class="comment">// 计算出范围</span></span><br><span class="line"><span class="keyword">var</span> ref = outputPos[<span class="number">0</span>] + <span class="string">':'</span> + outputPos[outputPos.length - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建 workbook 对象</span></span><br><span class="line"><span class="keyword">var</span> wb = &#123;</span><br><span class="line">    SheetNames: [<span class="string">'mySheet'</span>],</span><br><span class="line">    Sheets: &#123;</span><br><span class="line">        <span class="string">'mySheet'</span>: <span class="built_in">Object</span>.assign(&#123;&#125;, output, &#123; <span class="string">'!ref'</span>: ref &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出 Excel</span></span><br><span class="line">XLSX.writeFile(wb, <span class="string">'output.xlsx'</span>);</span><br></pre></td></tr></table></figure>
<h2 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://github.com/SheetJS/js-xlsx" target="_blank" rel="external">https://github.com/SheetJS/js-xlsx</a><br><a href="http://stackoverflow.com/questions/30859901/parse-xlsx-with-node-and-create-json" target="_blank" rel="external">http://stackoverflow.com/questions/30859901/parse-xlsx-with-node-and-create-json</a></p>

          
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/01/23/simple-flexbox/" itemprop="url">
                  简单易懂的 Flexbox
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-01-23T09:58:37+08:00" content="2016-01-23">
              2016-01-23
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/01/23/simple-flexbox/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/01/23/simple-flexbox/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="u7B80_u4ECB"><a href="#u7B80_u4ECB" class="headerlink" title="简介"></a>简介</h2><p>Flexbox 是 CSS 3 的布局方式，可以轻松实现传统布局中难以实现的布局。</p>
<h2 id="u57FA_u672C_u7528_u6CD5"><a href="#u57FA_u672C_u7528_u6CD5" class="headerlink" title="基本用法"></a>基本用法</h2><ol>
<li>设置父容器的 <code>display</code> 为 <code>flex</code>，然后调节容器相关的属性。</li>
<li>调节子元素相关的属性。</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"container"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"item"</span>&gt;</span>1<span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"item"</span>&gt;</span>2<span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"item"</span>&gt;</span>3<span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">.container &#123; display: flex; ... &#125;</span><br><span class="line">.item &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<h2 id="u5177_u4F53_u7528_u6CD5"><a href="#u5177_u4F53_u7528_u6CD5" class="headerlink" title="具体用法"></a>具体用法</h2><p>要使用 Flexbox 布局，你需要设置父容器和子元素的属性。</p>
<h3 id="u7236_u5BB9_u5668_u8BBE_u7F6E"><a href="#u7236_u5BB9_u5668_u8BBE_u7F6E" class="headerlink" title="父容器设置"></a>父容器设置</h3><ol>
<li><p>启用 flex 布局 <code>display: flex | inline-flex</code></p>
</li>
<li><p>设置主轴方向 <code>flex-direction: row | row-reverse | column | column-reverse</code></p>
<ul>
<li><code>row</code> 默认值，从左到右</li>
<li><code>row-reverse</code> 从右到左</li>
<li><code>column</code> 从上到下</li>
<li><code>column-reverse</code> 从下到上</li>
</ul>
</li>
<li><p>设置子元素的换行方式 <code>flex-wrap: nowrap | wrap | wrap-reverse</code></p>
<ul>
<li><code>nowrap</code> 默认值，让所有子元素排在一行中</li>
<li><code>wrap</code> 自动换行，方向为从右到左。(这里的方向是指换行方向，不是指排列方向)</li>
<li><code>wrap-reverse</code> 自动换行，方向为从左到右</li>
</ul>
</li>
<li><p><code>flex-direction</code> 和 <code>flex-wrap</code> 的简写：<code>flex-flow: &lt;&#39;flex-direction&#39;&gt; || &lt;&#39;flex-wrap&#39;&gt;</code> </p>
</li>
<li><p>设置子元素的在主轴中对齐方式 <code>justify-content: flex-start | flex-end | center | space-between | space-around</code></p>
<ul>
<li><code>flex-start</code> 默认值，在起始位置对齐。和 <code>flex-direction: row</code> 一起用的话相当于左对齐，和 <code>flex-direction: column</code> 一起用的话相当于上对齐</li>
<li><code>flex-end</code> 在终点位置对齐</li>
<li><code>center</code> 居中对齐</li>
<li><code>space-bewteen</code> 第一个子元素会在起始位置，最后一个子元素会在终点位置，它们之间的元素会在剩余位置中平均分布</li>
<li><code>space-around</code> 所有元素都会平均分布在容器中。注意，视觉上元素不是平均分布的。那是因为所有元素所占的空间都被平均分了，元素两边都有空间，第一个元素和最后一个元素靠近容器的边缘只有一份空间，其他空白的地方都是有两份空间组成的，所以看起来两边的空间少，而中间的空间多。好好体会一下 <code>space-around</code> 字面上的意思就能理解了。</li>
</ul>
</li>
<li><p>设置子元素在侧轴中的对齐方式 <code>align-items: flex-start | flex-end | center | baseline | stretch</code></p>
<ul>
<li><code>stretch</code> 默认值，拉伸元素来填充父容器</li>
<li><code>flex-start</code> 在侧轴的起始位置对齐</li>
<li><code>flex-end</code> 在侧轴的终点位置对齐</li>
<li><code>center</code> 居中于侧轴</li>
<li><code>baseline</code> 在基线对齐</li>
</ul>
</li>
<li><p>设置侧轴中行(不是元素)的对齐方式 <code>align-content: flex-start | flex-end | center | space-between | space-around | stretch</code></p>
<ul>
<li><code>stretch</code> 默认值，拉伸行来填充剩余的空间</li>
<li><code>flex-start</code> 所有行在容器的起始位置对齐</li>
<li><code>flex-end</code> 所有行在容器的终点位置对齐</li>
<li><code>center</code> 所有行居中于容器</li>
<li><code>space-between</code> 类似 <code>justify-content: space-between</code></li>
<li><code>space-around</code> 类似 <code>justify-content: space-around</code></li>
</ul>
</li>
</ol>
<h3 id="u5B50_u5143_u7D20_u8BBE_u7F6E"><a href="#u5B50_u5143_u7D20_u8BBE_u7F6E" class="headerlink" title="子元素设置"></a>子元素设置</h3><ol>
<li><p>设置元素的排序方式 <code>order: &lt;integer&gt;</code>，数字越小，排越前面。默认情况下是以文档流的先后顺序排序，负值合法。</p>
</li>
<li><p>调节元素的扩展能力 <code>flex-grow: &lt;number&gt;</code>，默认为1，增大该值表示该元素所占空间是其他元素的 n 倍，负值不合法。</p>
</li>
<li><p>调节元素的收缩能力 <code>flex-shrink: &lt;number&gt;</code>，默认为 1，减少该值表示该元素所站空间是其他元素的 1/n，负值不合法。</p>
</li>
<li><p>调节元素的基本大小：<code>flex-basis: &lt;length&gt; | auto</code>，默认为 auto。</p>
</li>
<li><p>上面属性的缩写：<code>flex: none | [ &lt;&#39;flex-grow&#39;&gt; &lt;&#39;flex-shrink&#39;&gt;? || &lt;&#39;flex-basis&#39;&gt; ]</code></p>
</li>
<li><p>指定元素的排列方式，作用和容器中的 <code>align-items</code> 类似，优先级比 <code>align-items</code> 高。</p>
</li>
</ol>
<p><strong>注意：<code>float</code>, <code>clear</code>, <code>vertical-align</code> 在子元素中不起作用。</strong></p>
<h2 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://css-tricks.com/snippets/css/a-guide-to-flexbox/" target="_blank" rel="external">https://css-tricks.com/snippets/css/a-guide-to-flexbox/</a><br><a href="http://www.w3cplus.com/css3/a-guide-to-flexbox.html" target="_blank" rel="external">http://www.w3cplus.com/css3/a-guide-to-flexbox.html</a><br><a href="http://zh.learnlayout.com/flexbox.html" target="_blank" rel="external">http://zh.learnlayout.com/flexbox.html</a></p>

          
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/01/22/spacemacs-usage/" itemprop="url">
                  Spacemacs 使用总结
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-01-22T15:20:38+08:00" content="2016-01-22">
              2016-01-22
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/01/22/spacemacs-usage/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/01/22/spacemacs-usage/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="u7B80_u4ECB"><a href="#u7B80_u4ECB" class="headerlink" title="简介"></a>简介</h2><p>Spacemacs 是一份 emacs 的配置文件，想要使用它，你先要有 emacs。</p>
<h2 id="u5B89_u88C5__26amp_3B__u4F7F_u7528"><a href="#u5B89_u88C5__26amp_3B__u4F7F_u7528" class="headerlink" title="安装 &amp; 使用"></a>安装 &amp; 使用</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/syl20bnr/spacemacs ~/.emacs.d</span><br><span class="line">$ emacs</span><br></pre></td></tr></table></figure>
<h2 id="u914D_u7F6E_u6587_u4EF6"><a href="#u914D_u7F6E_u6587_u4EF6" class="headerlink" title="配置文件"></a>配置文件</h2><p>Spacemacs 的配置文件位于 <code>~/.spacemacs</code> 中，我们只需要修改这个文件就可以制定自己的配置了。</p>
<p>一般情况下，我们只需要在 <code>dotspacemacs-configuration-layers</code> 中添加自己需要的 layer 就可以了。</p>
<h2 id="u5E38_u7528_u5FEB_u6377_u952E"><a href="#u5E38_u7528_u5FEB_u6377_u952E" class="headerlink" title="常用快捷键"></a>常用快捷键</h2><h4 id="u914D_u7F6E_u6587_u4EF6_u7BA1_u7406"><a href="#u914D_u7F6E_u6587_u4EF6_u7BA1_u7406" class="headerlink" title="配置文件管理"></a>配置文件管理</h4><p><code>SPC f e d</code> 快速打开配置文件 <code>.spacemacs</code><br><code>SPC f e R</code> 同步配置文件</p>
<h4 id="u6587_u4EF6_u7BA1_u7406"><a href="#u6587_u4EF6_u7BA1_u7406" class="headerlink" title="文件管理"></a>文件管理</h4><p><code>SPC f f</code> 打开文件（夹），相当于 <code>$ open xxx</code> 或 <code>$ cd /path/to/project</code><br><code>SPC p f</code> 搜索文件名，相当于 ST / Atom 中的 <code>Ctrl + p</code><br><code>SPC s a p</code> 搜索内容，相当于 <code>$ ag xxx</code> 或 ST / Atom 中的 <code>Ctrl + Shift + f</code></p>
<p><code>SPC b k</code> 关闭当前 buffer<br><code>SPC SPC</code> 搜索当前文件 </p>
<h4 id="u7A97_u53E3_u7BA1_u7406"><a href="#u7A97_u53E3_u7BA1_u7406" class="headerlink" title="窗口管理"></a>窗口管理</h4><p><code>SPC f t</code> 或 <code>SPC p t</code> 打开/关闭侧边栏，相当于 ST / Atom 中的 <code>Ctrl(cmd) + k + b</code><br><code>SPC f t</code> 打开当前文件所在的目录<br><code>SPC p t</code> 打开当前文件所在的根目录</p>
<p><code>SPC 0</code> 光标跳转到侧边栏（NeoTree）中<br><code>SPC n(数字)</code> 光标跳转到第 n 个 buffer 中</p>
<p><code>SPC w s | SPC w -</code> 水平分割窗口<br><code>SPC w v | SPC w /</code> 垂直分割窗口<br><code>SPC w c</code> 关闭当前窗口</p>
<h4 id="u5BF9_u9F50"><a href="#u5BF9_u9F50" class="headerlink" title="对齐"></a>对齐</h4><p><code>SPC j =</code> 自动对齐，相当于 beautify</p>
<h4 id="Shell__u96C6_u6210__28_u5FC5_u987B_u5148_u914D_u7F6E_Shell_layer_29"><a href="#Shell__u96C6_u6210__28_u5FC5_u987B_u5148_u914D_u7F6E_Shell_layer_29" class="headerlink" title="Shell 集成 (必须先配置 Shell layer)"></a>Shell 集成 (必须先配置 Shell layer)</h4><p><code>SPC &#39;(单引号)</code> 打开/关闭 Shell<br><code>C-k</code> 前一条 shell 命令，相当于在 shell 中按上箭头<br><code>C-j</code> 后一条 shell 命令，相当于在 shell 中按下箭头</p>
<h2 id="u8BA9_Spacemacs__u652F_u6301_EditorConfig"><a href="#u8BA9_Spacemacs__u652F_u6301_EditorConfig" class="headerlink" title="让 Spacemacs 支持 EditorConfig"></a>让 Spacemacs 支持 EditorConfig</h2><p>EditorConfig 是一个配置文件，一般位于项目的根目录，它可以让不同的编辑器和IDE 都按照相同的格式来格式化代码，对于项目的维护者来说是一个很好的工具。</p>
<p>Spacemacs 也支持 EditorConfig，只需要在配置文件中添加配置即可。下面以 OS X 为例，通过以下步骤即可让 Spacemacs 支持 EditorConfig：</p>
<ol>
<li><code>$ brew install editorconfig</code></li>
<li><p>在 <code>~/.spacemacs</code> 中的 <code>dotspacemacs-additional-packages</code> 中添加 <code>editorconfig</code>：</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="label">dotspacemacs</span>-<span class="keyword">additional-packages</span><br><span class="line"></span> <span class="string">'(</span><br><span class="line">   editorconfig</span><br><span class="line">   )</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>创建 .editorconfig 文件，写上自己喜欢的配置。</p>
</li>
<li>完。</li>
</ol>
<h2 id="u8BBE_u7F6E_u6587_u4EF6_u9ED8_u8BA4_u7684_u4E3B_u6A21_u5F0F"><a href="#u8BBE_u7F6E_u6587_u4EF6_u9ED8_u8BA4_u7684_u4E3B_u6A21_u5F0F" class="headerlink" title="设置文件默认的主模式"></a>设置文件默认的主模式</h2><p>虽然我们可以通过 <code>M-x</code> 来设置文件的主模式，但这种方式只是在单独修改某个文件的主模式时好用，如果要把所有同类型的文件都改成其他模式，这种方式的效率就太低了。</p>
<p>在 Spacemacs 中，我们可以用 <code>auto-mode-alist</code> 来设置某一类文件默认的主模式。</p>
<p>我们只需要在 <code>~/.spacemacs</code> 中的 <code>user-config</code> 中加入下面代码即可：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">(add-to-list &#39;auto-mode-alist &#39;(&#34;\\.js\\&#39;&#34; . react-mode))</span><br></pre></td></tr></table></figure>
<p>上面代码会用 <code>react-mode</code> 打开所有 <code>.js</code> 文件。</p>
<h2 id="Emacs__u670D_u52A1_u5668"><a href="#Emacs__u670D_u52A1_u5668" class="headerlink" title="Emacs 服务器"></a>Emacs 服务器</h2><p>Spacemacs 会在启动时启动服务器，这个服务器会在 Spacemacs 关闭的时候被杀掉。</p>
<h3 id="u4F7F_u7528_Emacs__u670D_u52A1_u5668"><a href="#u4F7F_u7528_Emacs__u670D_u52A1_u5668" class="headerlink" title="使用 Emacs 服务器"></a>使用 Emacs 服务器</h3><p>当 Emacs 服务器启动的时候，我们可以在命令行中使用 <code>emacsclient</code> 命令：</p>
<ul>
<li><code>$ emacsclient -c</code> 用 Emacs GUI 来打开文件</li>
<li><code>$ emacsclient -t</code> 用命令行中 Emacs 来打开文件</li>
</ul>
<h3 id="u6740_u6389_Emacs__u670D_u52A1_u5668"><a href="#u6740_u6389_Emacs__u670D_u52A1_u5668" class="headerlink" title="杀掉 Emacs 服务器"></a>杀掉 Emacs 服务器</h3><p>除了关闭 Spacemacs 之外，我们还可以用下面的命令来杀掉 Emacs 服务器：</p>
<ul>
<li><code>$ emacsclient -e &#39;(kill-emacs)&#39;</code></li>
</ul>
<h3 id="u6301_u4E45_u5316_Emacs__u670D_u52A1_u5668"><a href="#u6301_u4E45_u5316_Emacs__u670D_u52A1_u5668" class="headerlink" title="持久化 Emacs 服务器"></a>持久化 Emacs 服务器</h3><p>我们可以持久化 Emacs 服务器，在 Emacs 关闭的时候，服务器不被杀掉。只要设置 <code>~/.spacemacs</code> 中 <code>dotspacemacs-persistent-server</code> 为 <code>t</code> 即可。</p>
<p>但这种情况下，我们只可以通过以下方式来杀掉服务器了：</p>
<ul>
<li><code>SPC q q</code> 退出 Emacs 并杀掉服务器，会对已修改的 Buffer 给出保存的提示。</li>
<li><code>SPC q Q</code> 同上，但会丢失所有未保存的修改。</li>
</ul>
<h2 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://github.com/syl20bnr/spacemacs/blob/master/doc/DOCUMENTATION.org" target="_blank" rel="external">https://github.com/syl20bnr/spacemacs/blob/master/doc/DOCUMENTATION.org</a><br><a href="http://brannonlucas.com/using-editorconfig-and-spacemacs-on-os-x/" target="_blank" rel="external">http://brannonlucas.com/using-editorconfig-and-spacemacs-on-os-x/</a></p>

          
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/01/17/localtunnel-usage/" itemprop="url">
                  Localtunnel（Node.js 版） 使用教程
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-01-17T17:07:06+08:00" content="2016-01-17">
              2016-01-17
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/01/17/localtunnel-usage/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/01/17/localtunnel-usage/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="u7B80_u4ECB"><a href="#u7B80_u4ECB" class="headerlink" title="简介"></a>简介</h2><p>Localtunnel 是一个可以让内网服务器暴露到公网上的开源项目。</p>
<h2 id="u5BA2_u6237_u7AEF"><a href="#u5BA2_u6237_u7AEF" class="headerlink" title="客户端"></a>客户端</h2><h3 id="u5B89_u88C5"><a href="#u5B89_u88C5" class="headerlink" title="安装"></a>安装</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">$ npm install -g localtunnel</span><br></pre></td></tr></table></figure>
<h3 id="u4F7F_u7528"><a href="#u4F7F_u7528" class="headerlink" title="使用"></a>使用</h3><p>假设本地服务器在 8000 端口，我们可以通过下面的命令把本地服务器暴露到公网中</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">$ lt --port 8000&#10;your url is: https://uhhzexcifv.localtunnel.me</span><br></pre></td></tr></table></figure>
<p>通过上面的命令，我们不需要做其他设置就可以通过 <code>https://uhhzexcifv.localtunnel.me</code> 来访问我们本地服务器了。</p>
<p>由于 <code>localtunnel.me</code> 是国外的服务器，访问速度有时候不太理想，这时候我们可以自己搭建 localtunnel 的服务端。</p>
<h2 id="u670D_u52A1_u7AEF"><a href="#u670D_u52A1_u7AEF" class="headerlink" title="服务端"></a>服务端</h2><h3 id="u5B89_u88C5-1"><a href="#u5B89_u88C5-1" class="headerlink" title="安装"></a>安装</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">$ git clone git://github.com/defunctzombie/localtunnel-server.git&#10;$ cd localtunnel-server&#10;$ npm install</span><br></pre></td></tr></table></figure>
<h3 id="u4F7F_u7528-1"><a href="#u4F7F_u7528-1" class="headerlink" title="使用"></a>使用</h3><p>以监听 2000 端口为例：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"># &#30452;&#25509;&#20351;&#29992;&#10;$ bin/server --port 2000&#10;&#10;# &#37197;&#21512; pm2 &#20351;&#29992;&#10;$ pm2 start bin/server --name lt -- --port 2000</span><br></pre></td></tr></table></figure>
<p>启动服务端程序后，我们只要在使用客户端 <code>lt</code> 时加上 <code>--host</code> 参数，就可以指定服务端了。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"># host &#21518;&#38754;&#19981;&#35201;&#21152; /&#10;$ lt --host http://helloworld.com:2000 --port 8000&#10;your url is: http://jhuyudvlum.helloworld.com:2000</span><br></pre></td></tr></table></figure>
<p>这样，我们就可以通过自己的代理服务器来访问本地服务器了，不用经过第三方代理服务器，不必担心代理服务器的安全问题。</p>
<h2 id="u9AD8_u7EA7_u7528_u6CD5"><a href="#u9AD8_u7EA7_u7528_u6CD5" class="headerlink" title="高级用法"></a>高级用法</h2><h3 id="u53CD_u5411_u4EE3_u7406"><a href="#u53CD_u5411_u4EE3_u7406" class="headerlink" title="反向代理"></a>反向代理</h3><p>在 Github 上面有一份 Nginx 的<a href="https://github.com/localtunnel/server/blob/master/devops/nginx/sites/localtunnel" target="_blank" rel="external">配置</a>，我们可以直接使用，或者按照自己的需要做些修改。</p>
<h3 id="u6307_u5B9A_u5B50_u57DF_u540D"><a href="#u6307_u5B9A_u5B50_u57DF_u540D" class="headerlink" title="指定子域名"></a>指定子域名</h3><p>有时候，用随机字符串作为子域名并不是一件好事，我们可能需要固定的域名来访问本地服务器。这时，<code>lt --subdomain</code> 就可以派上用场了。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"># subdomain &#38480;&#21046;&#38271;&#24230;&#20026; 4 ~ 63&#10;$ lt --host http://helloworld.com:2000 --port 8000 --subdomain mysubdomain&#10;your url is: http://mysubdomain.helloworld.com:2000</span><br></pre></td></tr></table></figure>
<p>看到了吗？通过 <code>--subdomain</code>，我们就可以指定自己喜欢的子域名了。</p>
<h2 id="u5751"><a href="#u5751" class="headerlink" title="坑"></a>坑</h2><p><strong>然而</strong>，如果我们通过 <code>--host</code> 来指定子域名，会发生什么？</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">$ lt --host http://mysubdomain.hello.com --port 8000&#10;Error: localtunnel server returned an error, please try again</span><br></pre></td></tr></table></figure>
<p>就算配置了 Nginx 的反向代理，你依然会得到这个错误。可以查看 <a href="https://github.com/localtunnel/server/issues/21" target="_blank" rel="external">#21</a> 和  <a href="https://github.com/localtunnel/server/issues/31" target="_blank" rel="external">#31</a> 来看更多的细节。</p>
<p>要解决这个问题，最简单的就是 <strong>不用</strong> <code>--host</code> 来指定子域名，而用 <code>--subdomain</code> 来指定。</p>
<p>其实有好几个 pull request 都尝试去解决这个问题的，但不知道什么原因，作者一直没去合并。或者再过一段时间，这个问题就会解决，到时候， localtunnel 就会变得更加好用了。</p>
<h2 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://github.com/localtunnel/localtunnel" target="_blank" rel="external">https://github.com/localtunnel/localtunnel</a><br><a href="https://github.com/localtunnel/server" target="_blank" rel="external">https://github.com/localtunnel/server</a></p>

          
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/12/02/the-little-javascript-closures/" itemprop="url">
                  The Little JavaScript Closures
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-12-02T20:55:54+08:00" content="2015-12-02">
              2015-12-02
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2015/12/02/the-little-javascript-closures/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/02/the-little-javascript-closures/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="u5199_u5728_u524D_u9762"><a href="#u5199_u5728_u524D_u9762" class="headerlink" title="写在前面"></a>写在前面</h2><p>本文尝试模仿 <a href="http://uternet.github.io/TLS/" target="_blank" rel="external">The Little Schema</a> 的风格，介绍 JavaScript 的闭包。本文同时也是我学习 JavaScript 闭包的一次总结。欢迎一起讨论。</p>
<h2 id="u7B80_u4ECB"><a href="#u7B80_u4ECB" class="headerlink" title="简介"></a>简介</h2><p>什么是闭包？</p>
<blockquote>
<p>闭包是一个函数</p>
</blockquote>
<hr>
<p>闭包都是函数吗？</p>
<blockquote>
<p>是</p>
</blockquote>
<hr>
<p>函数都是闭包吗？</p>
<blockquote>
<p>不</p>
</blockquote>
<hr>
<p>我怎么判断一个函数是不是闭包？</p>
<blockquote>
<p>你现在还不能回答，因为你还不知道以下概念：<br>全局变量（Global Variable）<br>局部变量（Local Variable）<br>自由变量（Free Variable）<br>词法作用域（Lexical Scope）</p>
</blockquote>
<hr>
<h2 id="u53D8_u91CF_u4E0E_u4F5C_u7528_u57DF"><a href="#u53D8_u91CF_u4E0E_u4F5C_u7528_u57DF" class="headerlink" title="变量与作用域"></a>变量与作用域</h2><p><code>var a = 1;</code> a 是什么变量？</p>
<blockquote>
<p>全局变量</p>
</blockquote>
<hr>
<p><code>a = 1;</code> a 是什么变量？</p>
<blockquote>
<p>全局变量</p>
</blockquote>
<hr>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  a = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的 a，b 分别是什么变量？</p>
<blockquote>
<p>a 是全局变量，b 是局部变量</p>
</blockquote>
<hr>
<p>为什么 a 在函数中定义还是全局变量？</p>
<blockquote>
<p>因为 a 不是用 var 声明的</p>
</blockquote>
<hr>
<p>不用 <code>var</code> 声明的变量都是全局变量？</p>
<blockquote>
<p>是的</p>
</blockquote>
<hr>
<p>用 <code>var</code> 声明的变量都是局部变量？</p>
<blockquote>
<p>不是</p>
</blockquote>
<hr>
<p>为什么？</p>
<blockquote>
<p>在全局作用域中声明的变量都是全局变量，即使这个变量是用 var 声明的</p>
</blockquote>
<hr>
<p>全局作用域是什么？</p>
<blockquote>
<p>函数作用域以外的地方都是就是全局作用域</p>
</blockquote>
<hr>
<p>函数作用域又是什么？</p>
<blockquote>
<p>函数内部</p>
</blockquote>
<hr>
<p>可以举个例子吗？</p>
<blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> baz = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>foo 变量和 bar 函数都处于全局作用域中，baz 变量处于函数作用域中</p>
</blockquote>
<hr>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> bar = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码中有多少个作用域？</p>
<blockquote>
<p>2 个，foo 函数所处的全局作用域和 bar 变量所处的函数作用域</p>
</blockquote>
<hr>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> bar = <span class="number">1</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> test = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码中有多少个作用域？</p>
<blockquote>
<p>3 个，foo 函数所处的全局作用域，bar 所处的函数作用域，和 test 所处的函数作用域</p>
</blockquote>
<hr>
<p>上面的 bar 变量和 baz 函数处于同一个作用域吗？</p>
<blockquote>
<p>是的，因为它们都在 foo 函数中</p>
</blockquote>
<hr>
<p>上面 test 变量和 bar，baz处于同一个作用域中吗？</p>
<blockquote>
<p>不是，因为 test 变量在 baz 函数中</p>
</blockquote>
<hr>
<p>JavaScript 用函数来划分作用域吗？</p>
<blockquote>
<p>是的</p>
</blockquote>
<hr>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> bar = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(bar);</span><br></pre></td></tr></table></figure>
<p>会输出什么？</p>
<blockquote>
<p>Uncaught ReferenceError: bar is not defined</p>
</blockquote>
<hr>
<p>为什么会报错呢？</p>
<blockquote>
<p>因为外部作用域<strong>不能</strong>访问内部作用域</p>
</blockquote>
<hr>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(foo);</span><br><span class="line">&#125;</span><br><span class="line">bar();</span><br></pre></td></tr></table></figure>
<p>会输出什么？</p>
<blockquote>
<p>1</p>
</blockquote>
<hr>
<p>为什么不会报错？</p>
<blockquote>
<p>因为内部作用域<strong>可以</strong>访问外部作用域</p>
</blockquote>
<hr>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure>
<p>会输出什么？</p>
<blockquote>
<p>2</p>
</blockquote>
<hr>
<p>为什么不是输出 1 ？</p>
<blockquote>
<p>因为局部变量的优先级比外部变量高</p>
</blockquote>
<hr>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure>
<p>会输出什么？</p>
<blockquote>
<p>undefined<br>2</p>
</blockquote>
<hr>
<p>为什么会这么奇怪？</p>
<blockquote>
<p>因为变量声明有变量提升（Variable Hoisting）的过程</p>
</blockquote>
<hr>
<p>变量提升是什么？</p>
<blockquote>
<p>声明语句会在执行前被处理，在任何地方声明一个变量，相当于在顶部位置声明</p>
</blockquote>
<hr>
<p>可以举个例子吗？</p>
<blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">bla = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> bla;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bla;</span><br><span class="line">bla = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
</blockquote>
<hr>
<p>这和之前的例子有什么关系？</p>
<blockquote>
<p>函数内部声明的变量，都会先在函数的顶部声明。所以之前的例子就相当于<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">  x = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<hr>
<p>什么是词法作用域？</p>
<blockquote>
<p>变量的作用域是由它在源代码中所处位置决定的（词法），并且嵌套的函数可以访问到其外层作用域中声明的变量。</p>
</blockquote>
<hr>
<p>这和上面说到的内部作用域可以访问外部作用域有什么区别吗？</p>
<blockquote>
<p>没有</p>
</blockquote>
<hr>
<p>什么是自由变量？</p>
<blockquote>
<p>在函数内部使用到，但既不是该函数的参数，也不是该函数的局部变量的变量。</p>
</blockquote>
<hr>
<p>可以举个例子吗？</p>
<blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> baz = <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(foo + baz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里 bar 函数有三个变量：baz, console, foo<br>其中 baz 是局部变量， console 和 foo 都属于自由变量</p>
</blockquote>
<hr>
<p>为什么 console 和 foo 都是自由变量？</p>
<blockquote>
<p>因为 console 和 foo 都在全局作用域中，在 bar 函数中是通过引用的方式来使用 console 和 foo 的</p>
</blockquote>
<hr>
<p>还需要了解其他概念吗？</p>
<blockquote>
<p>不需要，现在已经可以深入了解闭包了</p>
</blockquote>
<hr>
<h2 id="u95ED_u5305"><a href="#u95ED_u5305" class="headerlink" title="闭包"></a>闭包</h2><p>什么是闭包？</p>
<blockquote>
<p>闭包是一个内部函数 [注1]</p>
</blockquote>
<hr>
<p>内部函数都是闭包吗？</p>
<blockquote>
<p>不是，引用了自由变量的内部函数才是闭包</p>
</blockquote>
<hr>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>foo 函数是一个闭包吗？</p>
<blockquote>
<p>不是，因为 foo 函数不是一个内部函数</p>
</blockquote>
<hr>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(x + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>bar 函数是一个闭包吗？</p>
<blockquote>
<p>不是，因为它只是一个内部函数，并没有引用自由变量</p>
</blockquote>
<hr>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>bar 函数是一个闭包吗？</p>
<blockquote>
<p>是的，因为它是一个内部函数，同时引用了自由变量</p>
</blockquote>
<hr>
<p>闭包有什么特点？</p>
<blockquote>
<ol>
<li>闭包可以访问外部变量</li>
<li>闭包可以在外部函数返回之后依然保留外部变量的引用</li>
<li>闭包会保留外部变量的引用，不是该变量的值</li>
</ol>
</blockquote>
<hr>
<p>第一点在前面的例子中已经懂了。</p>
<blockquote>
<p>很好</p>
</blockquote>
<hr>
<p>第二点还没懂，可以举个例子吗？</p>
<blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> add5 = add(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(add5(<span class="number">10</span>)) <span class="comment">// 15</span></span><br></pre></td></tr></table></figure>
<p>即便 add 函数已经返回，add5 中依然可以访问 x</p>
</blockquote>
<hr>
<p>第三点还没懂，可以举个例子吗？</p>
<hr>
<blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">user</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> id = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    getId: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> id; &#125;,</span><br><span class="line">    setId: <span class="function"><span class="keyword">function</span>(<span class="params">newId</span>) </span>&#123; id = newId &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = user();</span><br><span class="line">foo.getId(); <span class="comment">// 1</span></span><br><span class="line">foo.setId(<span class="number">2</span>);</span><br><span class="line">foo.getId(); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>这里闭包中的 id 是一个引用，不是实际值</p>
</blockquote>
<hr>
<p>有点像私有方法？</p>
<blockquote>
<p>是的，我们可以用闭包来实现私有方法</p>
</blockquote>
<hr>
<p>闭包还可以用来做什么？</p>
<blockquote>
<p>闭包是函数式编程的骨架，掌握闭包之后你可以写出函数式 JavaScript 代码。</p>
</blockquote>
<hr>
<p>函数式编程是什么？</p>
<blockquote>
<p>这不是本文的讨论范围，自己去学习吧。</p>
</blockquote>
<hr>
<h2 id="One_More_Thing"><a href="#One_More_Thing" class="headerlink" title="One More Thing"></a>One More Thing</h2><p>[注1] 根据 <a href="https://javascriptweblog.wordpress.com/2010/10/25/understanding-javascript-closures/" target="_blank" rel="external">Understanding JavaScript Closures</a> 这篇文章，事实上所有函数在创建的时候都会形成闭包。但这种闭包并没什么趣味，也没什么特别的用途，所以我们更关注的是由内部函数形成的闭包。</p>
<h2 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://uternet.github.io/TLS/" target="_blank" rel="external">http://uternet.github.io/TLS/</a><br><a href="http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures" target="_blank" rel="external">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures</a><br><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/var#var_hoisting" target="_blank" rel="external">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/var#var_hoisting</a><br><a href="http://javascriptissexy.com/understand-javascript-closures-with-ease/" target="_blank" rel="external">http://javascriptissexy.com/understand-javascript-closures-with-ease/</a><br><a href="http://javascriptissexy.com/javascript-variable-scope-and-hoisting-explained/" target="_blank" rel="external">http://javascriptissexy.com/javascript-variable-scope-and-hoisting-explained/</a><br><a href="http://stackoverflow.com/questions/12930272/javascript-closures-vs-anonymous-functions" target="_blank" rel="external">http://stackoverflow.com/questions/12930272/javascript-closures-vs-anonymous-functions</a><br><a href="https://javascriptweblog.wordpress.com/2010/10/25/understanding-javascript-closures/" target="_blank" rel="external">https://javascriptweblog.wordpress.com/2010/10/25/understanding-javascript-closures/</a><br><a href="http://www.moye.me/2014/12/29/closure_higher-order-function/" target="_blank" rel="external">http://www.moye.me/2014/12/29/closure_higher-order-function/</a></p>

          
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/11/17/react-dnd-usage/" itemprop="url">
                  React-DnD 的使用
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-11-17T10:59:31+08:00" content="2015-11-17">
              2015-11-17
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2015/11/17/react-dnd-usage/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/11/17/react-dnd-usage/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="u4ECB_u7ECD"><a href="#u4ECB_u7ECD" class="headerlink" title="介绍"></a>介绍</h2><p>React DnD 是一组 React 高阶组件，可以用来帮你构建复杂的拖拽接口，同时解耦你的组件。React DnD 非常适合像 Trello 和 Storify 这样的应用，在不同地方通过拖拽转移数据，而组件会改变它们的外观和应用的状态来响应拖拽事件。</p>
<h2 id="u57FA_u672C_u7528_u6CD5"><a href="#u57FA_u672C_u7528_u6CD5" class="headerlink" title="基本用法"></a>基本用法</h2><ol>
<li>把应用的根组件包装在 <code>DragDropContext</code> 中</li>
<li>把可以拖拽的组件包装在 <code>DragSource</code> 中<ol>
<li>设置 type</li>
<li>设置 spec，让组件可以响应拖拽事件</li>
<li>设置 collect，把拖拽过程中需要信息注入组件的 props</li>
</ol>
</li>
<li>把可以接受拖拽的组件包装在 <code>DropTarget</code> 中<ol>
<li>设置 type</li>
<li>设置 spec，让组件可以响应拖拽事件</li>
<li>设置 collect，把拖拽过程中需要信息注入组件的 props</li>
</ol>
</li>
<li>完</li>
</ol>
<p>翻译成代码就是：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="keyword">import</span> HTML5Backend <span class="keyword">from</span> <span class="string">'react-dnd-html5-backend'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; DragDropContext &#125; <span class="keyword">from</span> <span class="string">'react-dnd'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> DragDropContext(HTML5Backend)(App);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*---------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="keyword">import</span> &#123; DragSource &#125; <span class="keyword">from</span> <span class="string">'react-dnd'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> DragSource(type, spec, collect)(MyComponent);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*---------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="keyword">import</span> &#123; DropTarget &#125; <span class="keyword">from</span> <span class="string">'react-dnd'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent2</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> DropTarget(types, spec, collect)(MyComponent2);</span><br></pre></td></tr></table></figure>
<p>这样，MyComponent 就变得可以拖拽，而 MyComponent2 就变得可以接受拖拽了，但这并不代表 MyComponent 可以放到 MyComponent2 中！</p>
<h2 id="u4E00_u4E9B_u6982_u5FF5"><a href="#u4E00_u4E9B_u6982_u5FF5" class="headerlink" title="一些概念"></a>一些概念</h2><p>React DnD 中有一些特殊的概念，理解这些概念之后才能活用这个库！</p>
<ul>
<li><code>Backend</code> 实现 DnD 的方式，默认是用 HTML5 DnD API，它不能在触屏环境下工作，而且在 IE 下可定制性比其他浏览器弱。你也可以用自己实现，具体请看官方文档。</li>
<li><code>Items</code> 拖拽数据的表现形式，用 Object 来表示。譬如，要拖拽一张卡片，那这张卡片的<strong>数据</strong>的表现形式可能是 <code>{ id: xxx, content: yyy }</code>。</li>
<li><code>Types</code> 表示拖/放组件的兼容性，<code>DragSource</code> 和 <code>DropTarget</code> 必须指定 <code>type</code>。只有在 <code>type</code> 相同的情况下，<code>DragSource</code> 才能放到 <code>DropTarget</code> 中。</li>
<li><code>Monitors</code> 用来响应拖拽事件，可以用来更新组件的的状态。</li>
<li><code>Connectors</code> 底层接触 DOM 的东西，用来封装你的组件，让你的组件有拖拽的特性。一般在 collect 方法中指定，然后注入到组件的 props 中，最后 render 方法中包装你自己的组件。</li>
<li><code>DragSource &amp;&amp; DropTarget</code> 把上面的概念都绑在一起的东西，也是真正跟你的组件打交道的东西。</li>
</ul>
<h2 id="u4E3B_u8981_API__u4ECB_u7ECD"><a href="#u4E3B_u8981_API__u4ECB_u7ECD" class="headerlink" title="主要 API 介绍"></a>主要 API 介绍</h2><p>这些主要 API 都是通过包装你的组件，然后返回一个新的组件。</p>
<h3 id="DragDropContext_28backend_29"><a href="#DragDropContext_28backend_29" class="headerlink" title="DragDropContext(backend)"></a>DragDropContext(backend)</h3><ul>
<li><code>backend</code> 实现 DnD 的方式，一般是 HTML5Backend</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> DragDropContext(HTML5Backend)(App);</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="DragSource_28type_2C_spec_2C_collect_29"><a href="#DragSource_28type_2C_spec_2C_collect_29" class="headerlink" title="DragSource(type, spec, collect)"></a>DragSource(type, spec, collect)</h3><h3 id="DropTarget_28type_2C_spec_2C_collect_29"><a href="#DropTarget_28type_2C_spec_2C_collect_29" class="headerlink" title="DropTarget(type, spec, collect)"></a>DropTarget(type, spec, collect)</h3><ul>
<li><code>type</code> 必须。type 是自定义的，可以是 string，symbol，也可以是用一个函数来返回该组件的其他 props。该组件只能放到相同 type 的 DropTarget 中。</li>
<li><code>spec</code> 必须。一个带有特定方法的纯 Object，里面是一些响应拖拽事件的方法。</li>
<li><code>collect</code> 必须。一个函数返回一个 Object，这个 Object 会注入到组件的 props 中。</li>
<li><code>options</code> 可选。除非有性能问题，否则不需要关心这个参数。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> type = <span class="string">'xxx'</span>;</span><br><span class="line"><span class="keyword">const</span> spec = &#123; ... &#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">collect</span>(<span class="params">connect, monitor</span>) </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> DragSource(type, spec, collect)(MyComponent);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> DropTarget(type, spec, collect)(MyComponent2);</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="DragSource_23spec"><a href="#DragSource_23spec" class="headerlink" title="DragSource#spec"></a>DragSource#spec</h3><p>让你的组件响应 dnd 相关事件，支持以下方法：</p>
<ul>
<li><code>beginDrag(props, monitor, component)</code> <strong>必须</strong></li>
<li><code>endDrag(props, monitor, component)</code> 可选</li>
<li><code>canDrag(props, monitor)</code> 可选</li>
<li><code>isDragging(props, monitor)</code> 可选</li>
</ul>
<p>参数含义如下：</p>
<ul>
<li><code>props</code> 组件当前的 props</li>
<li><code>monitor</code> 是一个 <code>DragSourceMonitor</code> 实例，用来查询当前 drag state 的信息。</li>
<li><code>component</code> 表示当前组件，可以省略。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> spec = &#123;</span><br><span class="line">    beginDrag(props) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; </span><br><span class="line">        	id: props.id, </span><br><span class="line">        	content: props.content</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="DropTarget_23spec"><a href="#DropTarget_23spec" class="headerlink" title="DropTarget#spec"></a>DropTarget#spec</h3><p>让你的组件响应 dnd 相关事件，支持以下方法：</p>
<ul>
<li><code>drop(props, monitor, component)</code> 可选，响应 drop 事件</li>
<li><code>hover(props, monitor, component)</code> 可选</li>
<li><code>canDrop(props, monitor)</code> 可选</li>
</ul>
<p>参数含义如下：</p>
<ul>
<li><code>props</code> 组件当前的 props</li>
<li><code>monitor</code> 是一个 <code>DropTargetMonitor</code> 实例，用来查询当前 drag state 的信息。</li>
<li><code>component</code> 表示当前组件，可以省略。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> spec = &#123;</span><br><span class="line">	drop(props, monitor, component) &#123;</span><br><span class="line">		<span class="comment">// 获取正在拖放的数据</span></span><br><span class="line">		<span class="keyword">const</span> item = monitor.getItem();</span><br><span class="line">		<span class="comment">// 更新组件状态</span></span><br><span class="line">		component.setState(&#123;</span><br><span class="line">			item</span><br><span class="line">		&#125;)</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="DragSource_23collect_28connect_2C_monitor_29"><a href="#DragSource_23collect_28connect_2C_monitor_29" class="headerlink" title="DragSource#collect(connect, monitor)"></a>DragSource#collect(connect, monitor)</h3><h3 id="DropTarget_23collect_28connect_2C_monitor_29"><a href="#DropTarget_23collect_28connect_2C_monitor_29" class="headerlink" title="DropTarget#collect(connect, monitor)"></a>DropTarget#collect(connect, monitor)</h3><p>返回一个 object，这个 object 可以会注入到组件的 props 中。</p>
<ul>
<li><code>connect</code> 一个 <code>DragSourceConnector</code>/<code>DropTargetConnector</code> 实例，可以用 <code>connect.dragSource()</code>/<code>connect.dropTarget()</code> 来封装我们的组件。</li>
<li><code>monitor</code> 一个 <code>DragSourceMonitor</code>/<code>DropTargetMonitor</code> 实例，用来查询当前拖拽的信息。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">collect</span>(<span class="params">connect, monitor</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        isDragging: monitor.isDragging(),</span><br><span class="line">        connectDragSource: connect.dragSource()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">	render() &#123;</span><br><span class="line">		<span class="comment">// 可以访问 collect 中返回的  object</span></span><br><span class="line">		<span class="keyword">const</span> &#123; isDragging, connectDragSource &#125; = <span class="keyword">this</span>.props;</span><br><span class="line">		<span class="comment">// 需要用 connect.dragSource()/connect.dropTarget() 封装自己的组件</span></span><br><span class="line">		<span class="keyword">return</span> connectDragSource(</span><br><span class="line">			<span class="xml"><span class="tag">&lt;<span class="title">div</span>&gt;</span>123<span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">		)</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u5177_u4F53_u4F8B_u5B50"><a href="#u5177_u4F53_u4F8B_u5B50" class="headerlink" title="具体例子"></a>具体例子</h2><ul>
<li><a href="http://gaearon.github.io/react-dnd/examples-chessboard-tutorial-app.html" target="_blank" rel="external">演示</a></li>
<li><a href="https://github.com/gaearon/react-dnd/tree/master/examples" target="_blank" rel="external">代码</a></li>
</ul>
<h2 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://gaearon.github.io/react-dnd/" target="_blank" rel="external">官方文档</a></p>

          
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/10/25/birthday-summary/" itemprop="url">
                  写在二十四岁生日
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-10-25T17:38:50+08:00" content="2015-10-25">
              2015-10-25
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/life/" itemprop="url" rel="index">
                    <span itemprop="name">life</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2015/10/25/birthday-summary/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/10/25/birthday-summary/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>又一年过去了，今年是第四年。<br>今年的生日是和女朋友一起，平平淡淡地过的。<br>回顾今年，我做的事情基本都是读书，学习，工作，陪妹子。</p>
<p>相信大家都知道读书的好处，但很多人在工作之后都会抱怨没时间读书，包括我自己。但人们常说，时间是挤出来的。所以，我也试着去挤时间——把上下班坐地铁/公交的时间利用起来。于是乎，这一年下来看的书大概有：</p>
<ul>
<li>《三体系列》</li>
<li>《啊哈，算法》</li>
<li>《黑客与画家》</li>
<li>《Rework-重来：更为简单有效的商业思维》</li>
<li>《失控》</li>
<li>《教训》</li>
<li>《跨界》</li>
<li>《把时间当朋友》</li>
<li>《JavaScript 函数式编程》</li>
<li>《The Little Schemer》</li>
<li>《实用 Common Lisp 编程》</li>
</ul>
<p>还有其他还没看完的技术书/文章。<br>这样看下来今年看得书不多不少，时间利用率还算可以吧。</p>
<p>从上面的书单可以看到，其实我今年开始去学习函数式语言了。我想去了解下面向对象之外的世界是怎样的。至于到底会不会用上这些技术，以后才知道，现在只管学就好了。</p>
<p>工作上面，今年年中的时候以前的老大找过我，问我要不要跟他一起干，说他能给我我现在拥有的一切给我，还把项目的一切控制权交给我，其实他们的项目前景还是挺好的，但跟我的技术栈不符合，加上我对他们所在行业不太感兴趣，所以只好推掉了~看以后还有没有机会合作~</p>
<p>另外，我今年还试着做了一个开源的网站，<a href="http://aniquo.com" target="_blank" rel="external">http://aniquo.com</a> 大家有兴趣的可以去围观一下。没什么特别有趣的东西，只有我自己收录的一些经典的语录而已。本来是想把它做成一个语录搜索系统的，但精力有限，现阶段大概算是一个可用的版本。至于用户量，从头到尾都只有我一个，233. 继续做这个的原因，只剩下情怀了。如果有人有兴趣的话，联系我吧~至于源码，到 github 搜下就找到了，写的很烂的东西。</p>
<p>今年的总结大概就这些了~</p>

          
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/10/22/node-stream-api-learning/" itemprop="url">
                  Node.js 中 Stream API 的使用
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-10-22T17:09:06+08:00" content="2015-10-22">
              2015-10-22
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/javascript/" itemprop="url" rel="index">
                    <span itemprop="name">javascript</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2015/10/22/node-stream-api-learning/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/10/22/node-stream-api-learning/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="u57FA_u672C_u4ECB_u7ECD"><a href="#u57FA_u672C_u4ECB_u7ECD" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>在 Node.js 中，读取文件的方式有两种，一种是用 <code>fs.readFile</code>，另外一种是利用 <code>fs.createReadStream</code> 来读取。</p>
<p><code>fs.readFile</code> 对于每个 Node.js 使用者来说最熟悉不过了，简单易懂，很好上手。但它的缺点是会先将数据全部读入内存，一旦遇到大文件的时候，这种方式读取的效率就非常低下了。</p>
<p>而 <code>fs.createReadStream</code> 则是通过 Stream 来读取数据，它会把文件（数据）分割成小块，然后触发一些特定的事件，我们可以监听这些事件，编写特定的处理函数。这种方式相对上面来说，并不好上手，但它效率非常高。</p>
<p>事实上， Stream 在 Node.js 中并非仅仅用在文件处理上，其他地方也可以看到它的身影，如 <code>process.stdin/stdout</code>, <code>http</code>, <code>tcp sockets</code>, <code>zlib</code>, <code>crypto</code> 等都有用到。</p>
<p>本文是我学习 Node.js 中的 Stream API 中的一点总结，希望对大家有用。</p>
<h2 id="u7279_u70B9"><a href="#u7279_u70B9" class="headerlink" title="特点"></a>特点</h2><ul>
<li>基于事件通讯</li>
<li>可以通过 <code>pipe</code> 来连接流</li>
</ul>
<h2 id="u79CD_u7C7B"><a href="#u79CD_u7C7B" class="headerlink" title="种类"></a>种类</h2><ul>
<li>Readable Stream  可读数据流</li>
<li>Writeable Stream  可写数据流</li>
<li>Duplex Stream  双向数据流，可以同时读和写</li>
<li>Transform Stream 转换数据流，可读可写，同时可以转换（处理）数据</li>
</ul>
<h2 id="u4E8B_u4EF6"><a href="#u4E8B_u4EF6" class="headerlink" title="事件"></a>事件</h2><h3 id="u53EF_u8BFB_u6570_u636E_u6D41_u7684_u4E8B_u4EF6"><a href="#u53EF_u8BFB_u6570_u636E_u6D41_u7684_u4E8B_u4EF6" class="headerlink" title="可读数据流的事件"></a>可读数据流的事件</h3><ul>
<li><code>readable</code> 数据向外流时触发</li>
<li><code>data</code> 对于那些没有显式暂停的数据流，添加data事件监听函数，会将数据流切换到流动态，尽快向外提供数据</li>
<li><code>end</code> 读取完数据时触发。注意不能和 <code>writeableStream.end()</code> 混淆，writeableStream 并没有 end 事件，只有 <code>.end()</code> 方法</li>
<li><code>close</code> 数据源关闭时触发</li>
<li><code>error</code> 读取数据发生错误时触发</li>
</ul>
<h3 id="u53EF_u5199_u6570_u636E_u6D41_u7684_u4E8B_u4EF6"><a href="#u53EF_u5199_u6570_u636E_u6D41_u7684_u4E8B_u4EF6" class="headerlink" title="可写数据流的事件"></a>可写数据流的事件</h3><ul>
<li><code>drain</code> <code>writable.write(chunk)</code> 返回 false 之后，缓存全部写入完成，可以重新写入时就会触发</li>
<li><code>finish</code> 调用 <code>.end</code> 方法时，所有缓存的数据释放后触发，类似于可读数据流中的 <strong>end</strong> 事件，表示写入过程结束</li>
<li><code>pipe</code> 作为 pipe 目标时触发</li>
<li><code>unpipe</code> 作为 unpipe 目标时触发</li>
<li><code>error</code> 写入数据发生错误时触发</li>
</ul>
<h2 id="u72B6_u6001"><a href="#u72B6_u6001" class="headerlink" title="状态"></a>状态</h2><p>可读数据流有两种状态：<strong>流动态</strong> 和 <strong>暂停态</strong>，改变数据流状态的方法如下：</p>
<p><strong>暂停态 -&gt; 流动态</strong></p>
<ul>
<li>添加 data 事件的监听函数</li>
<li>调用 resume 方法</li>
<li>调用 pipe 方法</li>
</ul>
<p><strong>注意：</strong> 如果转为流动态时，没有 data 事件的监听函数，也没有 pipe 方法的目的地，那么数据将遗失。</p>
<p><strong>流动态 -&gt; 暂停态</strong></p>
<ul>
<li>不存在 pipe 方法的目的地时，调用 pause 方法</li>
<li>存在 pipe 方法的目的地时，移除所有 data 事件的监听函数，并且调用 unpipe 方法，移除所有 pipe 方法的目的地</li>
</ul>
<p><strong>注意：</strong> 只移除 data 事件的监听函数，并不会自动引发数据流进入「暂停态」。另外，存在 pipe 方法的目的地时，调用 pause 方法，并不能保证数据流总是处于暂停态，一旦那些目的地发出数据请求，数据流有可能会继续提供数据。</p>
<h2 id="u7528_u6CD5"><a href="#u7528_u6CD5" class="headerlink" title="用法"></a>用法</h2><h3 id="u8BFB_u5199_u6587_u4EF6"><a href="#u8BFB_u5199_u6587_u4EF6" class="headerlink" title="读写文件"></a>读写文件</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="comment">// 新建可读数据流</span></span><br><span class="line"><span class="keyword">var</span> rs = fs.createReadStream(<span class="string">'./test1.txt'</span>);</span><br><span class="line"><span class="comment">// 新建可写数据流</span></span><br><span class="line"><span class="keyword">var</span> ws = fs.createWriteStream(<span class="string">'./test2.txt'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听可读数据流结束事件</span></span><br><span class="line">rs.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'read text1.txt successfully!'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 监听可写数据流结束事件</span></span><br><span class="line">ws.on(<span class="string">'finish'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'write text2.txt successfully!'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 把可读数据流转换成流动态，流进可写数据流中</span></span><br><span class="line">rs.pipe(ws);</span><br></pre></td></tr></table></figure>
<h3 id="u8BFB_u53D6_CSV__u6587_u4EF6_uFF0C_u5E76_u4E0A_u4F20_u6570_u636E_uFF08_u6211_u5728_u751F_u4EA7_u73AF_u5883_u4E2D_u5199_u8FC7_uFF09"><a href="#u8BFB_u53D6_CSV__u6587_u4EF6_uFF0C_u5E76_u4E0A_u4F20_u6570_u636E_uFF08_u6211_u5728_u751F_u4EA7_u73AF_u5883_u4E2D_u5199_u8FC7_uFF09" class="headerlink" title="读取 CSV 文件，并上传数据（我在生产环境中写过）"></a>读取 CSV 文件，并上传数据（我在生产环境中写过）</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">var</span> es = <span class="built_in">require</span>(<span class="string">'event-stream'</span>);</span><br><span class="line"><span class="keyword">var</span> csv = <span class="built_in">require</span>(<span class="string">'csv'</span>);</span><br><span class="line"><span class="keyword">var</span> parser = csv.parse();</span><br><span class="line"><span class="keyword">var</span> transformer = csv.transform(<span class="function"><span class="keyword">function</span>(<span class="params">record</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> record.join(<span class="string">','</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> data = fs.createReadStream(<span class="string">'./demo.csv'</span>);</span><br><span class="line">data</span><br><span class="line">    .pipe(parser)</span><br><span class="line">    .pipe(transformer)</span><br><span class="line">    <span class="comment">// 处理前一个 stream 传递过来的数据</span></span><br><span class="line">    .pipe(es.map(<span class="function"><span class="keyword">function</span>(<span class="params">data, callback</span>) </span>&#123;</span><br><span class="line">        upload(data, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">            callback(err);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;))</span><br><span class="line">    <span class="comment">// 相当于监听前一个 stream 的 end 事件</span></span><br><span class="line">    .pipe(es.wait(<span class="function"><span class="keyword">function</span>(<span class="params">err, body</span>) </span>&#123;</span><br><span class="line">        process.stdout.write(<span class="string">'done!'</span>);</span><br><span class="line">    &#125;));</span><br></pre></td></tr></table></figure>
<h3 id="u66F4_u591A_u7528_u6CD5"><a href="#u66F4_u591A_u7528_u6CD5" class="headerlink" title="更多用法"></a>更多用法</h3><p>可以参考一下 <a href="https://github.com/jeresig/node-stream-playground" target="_blank" rel="external">https://github.com/jeresig/node-stream-playground</a> ，进去示例网站之后直接点 add stream 就能看到结果了。</p>
<h2 id="u5E38_u89C1_u5751"><a href="#u5E38_u89C1_u5751" class="headerlink" title="常见坑"></a>常见坑</h2><ul>
<li>用 <code>rs.pipe(ws)</code> 的方式来写文件并不是把 rs 的内容 append 到 ws 后面，而是直接用 rs 的内容覆盖 ws 原有的内容</li>
<li>已结束/关闭的流不能重复使用，必须重新创建数据流</li>
<li><p>pipe 方法返回的是目标数据流，如 <code>a.pipe(b)</code> 返回的是 b，因此监听事件的时候请注意你监听的对象是否正确</p>
<ul>
<li><p>如果你要监听多个数据流，同时你又使用了 pipe 方法来串联数据流的话，你就要写成：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">data</span><br><span class="line">    .on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'data end'</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    .pipe(a)</span><br><span class="line">    .on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'a end'</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    .pipe(b)</span><br><span class="line">    .on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'b end'</span>);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="u5E38_u7528_u7C7B_u5E93"><a href="#u5E38_u7528_u7C7B_u5E93" class="headerlink" title="常用类库"></a>常用类库</h2><ul>
<li><a href="https://github.com/dominictarr/event-stream" target="_blank" rel="external">event-stream</a> 用起来有函数式编程的感觉，个人比较喜欢</li>
<li><a href="https://github.com/sindresorhus/awesome-nodejs#streams" target="_blank" rel="external">awesome-nodejs#streams</a> 由于其他 stream 库我都没用过，所以有需求的就直接看这里吧</li>
</ul>
<h2 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://javascript.ruanyifeng.com/nodejs/stream.html" target="_blank" rel="external">阮一峰 - stream接口</a><br><a href="https://nodejs.org/api/stream.html" target="_blank" rel="external">nodejs.org Stream</a><br><a href="http://codewinds.com/blog/2013-08-20-nodejs-transform-streams.html" target="_blank" rel="external">Transforming data with Node.js transform streams</a><br><a href="http://stackoverflow.com/questions/18335499/nodejs-whats-the-difference-between-a-duplex-stream-and-a-transform-stream" target="_blank" rel="external">NodeJS: What’s the difference between a Duplex stream and a Transform stream?</a></p>

          
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    

  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="https://avatars2.githubusercontent.com/u/2386165"
               alt="Scarletsky" />
          <p class="site-author-name" itemprop="name">Scarletsky</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">26</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>
          
          
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">21</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="icon-next-heart fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Scarletsky</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>



      </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  


  



  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=0.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=0.5.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=0.5.0"></script>



  



  

    <script type="text/javascript">
      var disqus_shortname = 'scarletskygithubio';
      var disqus_identifier = 'index.html';
      var disqus_title = '';
      var disqus_url = '';

      function run_disqus_script(disqus_script){
        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      }

      run_disqus_script('count.js');
      
    </script>
  



  
  

  
  


</body>
</html>
